<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Obsidian Vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>Obsidian Vault</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 30 May 2025 20:12:32 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 30 May 2025 20:12:29 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Matrix3Extensions.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Extensions
{
    public static class MatrixExtensions
    {
        // for god knows why using instanced rendering (or more so, passing the matrix as a layout) fucks up the rotation
        public static Matrix4 RotateMatrixForInstancedRendering(this Matrix4 m)
        {
            return new Matrix4(
                m.Row0.X,
                m.Row1.X,
                m.Row2.X,
                m.Row3.X,
                m.Row0.Y,
                m.Row1.Y,
                m.Row2.Y,
                m.Row3.Y,
                m.Row0.Z,
                m.Row1.Z,
                m.Row2.Z,
                m.Row3.Z,
                m.Row0.W,
                m.Row1.W,
                m.Row2.W,
                m.Row3.W
            );
        }
    }
}
]]></description><link>api\extensions\matrix3extensions.cs.html</link><guid isPermaLink="false">API/Extensions/Matrix3Extensions.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[VectorExtensions.cs]]></title><description><![CDATA[ 
 <br>using System.Globalization;
using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Extensions
{
    public static class VectorExtensions
    {
        #region m*th
        public static Vector3 ToRadians(this Vector3 angles)
        {
            return new Vector3(
                MathHelper.DegreesToRadians(angles.X),
                MathHelper.DegreesToRadians(angles.Y),
                MathHelper.DegreesToRadians(angles.Z)
            );
        }

        public static Vector3 ToDegrees(this Vector3 radians)
        {
            return new Vector3(
                MathHelper.RadiansToDegrees(radians.X),
                MathHelper.RadiansToDegrees(radians.Y),
                MathHelper.RadiansToDegrees(radians.Z)
            );
        }

        /// &lt;summary&gt;
        /// top left , top right, bottom left, bottom right
        /// &lt;/summary&gt;
        /// &lt;param name="vector3"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Vector3[] CreateSquare(this Vector3 vector)
        {
            return
            [
                new(-vector.X / 2f, vector.Y / 2f, 0f),
                new(vector.X / 2f, vector.Y / 2f, 0f),
                new(-vector.X / 2f, -vector.Y / 2f, 0f),
                new(vector.X / 2f, -vector.Y / 2f, 0f),
            ];
        }

        /// &lt;summary&gt;
        /// direction vector to eulers radians
        /// &lt;/summary&gt;
        /// &lt;param name="directionVector"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Vector3 DirectionToEulerRadians(this Vector3 directionVector)
        {
            directionVector = Vector3.Normalize(directionVector);
            float yaw = MathF.Atan2(directionVector.X, directionVector.Z);
            float pitch = MathF.Asin(-directionVector.Y);
            float roll = 0f;
            return new Vector3(roll, pitch, yaw);
        }

        /// &lt;summary&gt;
        /// takes radians and outputs direction vector
        /// &lt;/summary&gt;
        /// &lt;param name="radians"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Vector3 TurnToDirectionVector(this Vector3 radians)
        {
            Vector3 outVector = new Vector3();
            outVector.X = MathF.Cos(radians.Z) * MathF.Cos(radians.Y);
            outVector.Y = MathF.Sin(radians.Z) * MathF.Cos(radians.Y);
            outVector.Z = MathF.Sin(radians.Y);
            return outVector;
        }
        #endregion

        #region colors
        public static Vector4 ToVector4(this Color4 color) =&gt;
            new(color.R, color.G, color.B, color.A);

        public static Color4 ToColor4(this Vector4 color) =&gt;
            new(color.X, color.Y, color.Z, color.W);

        public static string ToHex(this Vector4 color) =&gt;
            $"{(int)(color.X * 255):X2}{(int)(color.Y * 255):X2}{(int)(color.Z * 255):X2}{(int)(color.W * 255):X2}";

        public static Vector4 FromHex(string hex) =&gt;
            new Vector4(
                byte.Parse(hex.Substring(0, 2), NumberStyles.HexNumber) / 255f,
                byte.Parse(hex.Substring(2, 2), NumberStyles.HexNumber) / 255f,
                byte.Parse(hex.Substring(4, 2), NumberStyles.HexNumber) / 255f,
                byte.Parse(hex.Substring(6, 2), NumberStyles.HexNumber) / 255f
            );
        #endregion
    }
}
]]></description><link>api\extensions\vectorextensions.cs.html</link><guid isPermaLink="false">API/Extensions/VectorExtensions.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[LoadJsonFromFile.cs]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.JSON
{
    public class LoadJsonFromFile&lt;T&gt;
        where T : class
    {
        public static T? Load(string path)
        {
            string json = System.IO.File.ReadAllText(path);
            T data = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;T&gt;(json)!;
            return data;
        }
    }
}
]]></description><link>api\json\loadjsonfromfile.cs.html</link><guid isPermaLink="false">API/JSON/LoadJsonFromFile.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[MCSDFJson.cs]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.JSON
{
    public class MCSDFJSON
    {
        #region font classes
        public class Atlas
        {
            public string type { get; set; }
            public float distanceRange { get; set; }
            public float distanceRangeMiddle { get; set; }
            public float size { get; set; }
            public int width { get; set; }
            public int height { get; set; }
            public string yOrigin { get; set; }
        }

        public class Metrics
        {
            public float emSize { get; set; }
            public float lineHeight { get; set; }
            public float ascender { get; set; }
            public float descender { get; set; }
            public float underlineY { get; set; }
            public float underlineThickness { get; set; }
        }

        public class Bounds
        {
            public float left { get; set; }
            public float bottom { get; set; }
            public float right { get; set; }
            public float top { get; set; }
        }

        public class Glyph
        {
            public int unicode { get; set; }
            public float advance { get; set; }
            public Bounds planeBounds { get; set; } // Optional: some glyphs like space may not have this
            public Bounds atlasBounds { get; set; }
        }

        public class FontJson
        {
            public Atlas atlas { get; set; }
            public Metrics metrics { get; set; }
            public List&lt;Glyph&gt; glyphs { get; set; }
        }
        #endregion


        public static FontJson? GetFontJson(string jsonPath) =&gt;
            LoadJsonFromFile&lt;FontJson&gt;.Load(jsonPath)!;
    }
}
]]></description><link>api\json\mcsdfjson.cs.html</link><guid isPermaLink="false">API/JSON/MCSDFJson.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[EasingFunctions.cs]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Misc
{ // source: https://gist.github.com/Kryzarel/bba64622057f21a1d6d44879f9cd7bd4#file-easingfunctions-cs
    // Made with the help of this great post: https://joshondesign.com/2013/03/01/improvedEasingEquations

    // --------------------------------- Other Related Links --------------------------------------------------------------------
    // Original equations, bad formulation:	https://github.com/danro/jquery-easing/blob/master/jquery.easing.js
    // A few equations, very simplified:	https://gist.github.com/gre/1650294
    // Easings.net equations, simplified:	https://github.com/ai/easings.net/blob/master/src/easings/easingsFunctions.ts

    public static class EasingFunctions
    {
        public static float Linear(float t) =&gt; t;

        public static float InQuad(float t) =&gt; t * t;

        public static float OutQuad(float t) =&gt; 1 - InQuad(1 - t);

        public static float InOutQuad(float t)
        {
            if (t &lt; 0.5)
                return InQuad(t * 2) / 2;
            return 1 - InQuad((1 - t) * 2) / 2;
        }

        public static float InCubic(float t) =&gt; t * t * t;

        public static float OutCubic(float t) =&gt; 1 - InCubic(1 - t);

        public static float InOutCubic(float t)
        {
            if (t &lt; 0.5)
                return InCubic(t * 2) / 2;
            return 1 - InCubic((1 - t) * 2) / 2;
        }

        public static float InQuart(float t) =&gt; t * t * t * t;

        public static float OutQuart(float t) =&gt; 1 - InQuart(1 - t);

        public static float InOutQuart(float t)
        {
            if (t &lt; 0.5)
                return InQuart(t * 2) / 2;
            return 1 - InQuart((1 - t) * 2) / 2;
        }

        public static float InQuint(float t) =&gt; t * t * t * t * t;

        public static float OutQuint(float t) =&gt; 1 - InQuint(1 - t);

        public static float InOutQuint(float t)
        {
            if (t &lt; 0.5)
                return InQuint(t * 2) / 2;
            return 1 - InQuint((1 - t) * 2) / 2;
        }

        public static float InSine(float t) =&gt; 1 - (float)Math.Cos(t * Math.PI / 2);

        public static float OutSine(float t) =&gt; (float)Math.Sin(t * Math.PI / 2);

        public static float InOutSine(float t) =&gt; (float)(Math.Cos(t * Math.PI) - 1) / -2;

        public static float InExpo(float t) =&gt; (float)Math.Pow(2, 10 * (t - 1));

        public static float OutExpo(float t) =&gt; 1 - InExpo(1 - t);

        public static float InOutExpo(float t)
        {
            if (t &lt; 0.5)
                return InExpo(t * 2) / 2;
            return 1 - InExpo((1 - t) * 2) / 2;
        }

        public static float InCirc(float t) =&gt; -((float)Math.Sqrt(1 - t * t) - 1);

        public static float OutCirc(float t) =&gt; 1 - InCirc(1 - t);

        public static float InOutCirc(float t)
        {
            if (t &lt; 0.5)
                return InCirc(t * 2) / 2;
            return 1 - InCirc((1 - t) * 2) / 2;
        }

        public static float InElastic(float t) =&gt; 1 - OutElastic(1 - t);

        public static float OutElastic(float t)
        {
            float p = 0.3f;
            return (float)Math.Pow(2, -10 * t) * (float)Math.Sin((t - p / 4) * (2 * Math.PI) / p)
                + 1;
        }

        public static float InOutElastic(float t)
        {
            if (t &lt; 0.5)
                return InElastic(t * 2) / 2;
            return 1 - InElastic((1 - t) * 2) / 2;
        }

        public static float InBack(float t)
        {
            float s = 1.70158f;
            return t * t * ((s + 1) * t - s);
        }

        public static float OutBack(float t) =&gt; 1 - InBack(1 - t);

        public static float InOutBack(float t)
        {
            if (t &lt; 0.5)
                return InBack(t * 2) / 2;
            return 1 - InBack((1 - t) * 2) / 2;
        }

        public static float InBounce(float t) =&gt; 1 - OutBounce(1 - t);

        public static float OutBounce(float t)
        {
            float div = 2.75f;
            float mult = 7.5625f;

            if (t &lt; 1 / div)
            {
                return mult * t * t;
            }
            else if (t &lt; 2 / div)
            {
                t -= 1.5f / div;
                return mult * t * t + 0.75f;
            }
            else if (t &lt; 2.5 / div)
            {
                t -= 2.25f / div;
                return mult * t * t + 0.9375f;
            }
            else
            {
                t -= 2.625f / div;
                return mult * t * t + 0.984375f;
            }
        }

        public static float InOutBounce(float t)
        {
            if (t &lt; 0.5)
                return InBounce(t * 2) / 2;
            return 1 - InBounce((1 - t) * 2) / 2;
        }
    }
}
]]></description><link>api\misc\easingfunctions.cs.html</link><guid isPermaLink="false">API/Misc/EasingFunctions.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[Logger.cs]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Misc
{
    public class Logger
    {
        public static void Log(string info, LogLevel level)
        {
            switch (level)
            {
                case LogLevel.Info:
                    Log(info, LogColors.BRIGHT_BLUE);
                    break;
                case LogLevel.Detail:
                    Log(info, LogColors.BRIGHT_BLACK);
                    break;
                case LogLevel.Warning:
                    Log(info, LogColors.BRIGHT_YELLOW);
                    break;
                case LogLevel.Error:
                    Log(info, LogColors.BRIGHT_RED);
                    break;
                default:
                    Log(info, LogColors.BRIGHT_WHITE);
                    break;
            }
            // since we change the color when we log, logging without us changing color means the app crashed, so we should set the color to red
            Console.ForegroundColor = ConsoleColor.Red;
        }

        public static void Log(string info, string color)
        {
            // replace return to normals with the current color so we can change the color of texts
            Console.WriteLine(color + info.Replace(LogColors.NORMAL, color));
        }
    }

    public enum LogLevel
    {
        Info,
        Detail,
        Warning,
        Error,
    }

    public class LogColors
    {
        // https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
        #region Colors
        public static string NORMAL = Console.IsOutputRedirected ? "" : "RETURN_TO_NORMAL";
        public static string BLACK = Console.IsOutputRedirected ? "" : "\x1b[30m";
        public static string RED = Console.IsOutputRedirected ? "" : "\x1b[31m";
        public static string GREEN = Console.IsOutputRedirected ? "" : "\x1b[32m";
        public static string YELLOW = Console.IsOutputRedirected ? "" : "\x1b[33m";
        public static string BLUE = Console.IsOutputRedirected ? "" : "\x1b[34m";
        public static string MAGENTA = Console.IsOutputRedirected ? "" : "\x1b[35m";
        public static string CYAN = Console.IsOutputRedirected ? "" : "\x1b[36m";
        public static string WHITE = Console.IsOutputRedirected ? "" : "\x1b[37m";
        public static string BRIGHT_BLACK = Console.IsOutputRedirected ? "" : "\x1b[90m";
        public static string BRIGHT_RED = Console.IsOutputRedirected ? "" : "\x1b[91m";
        public static string BRIGHT_GREEN = Console.IsOutputRedirected ? "" : "\x1b[92m";
        public static string BRIGHT_YELLOW = Console.IsOutputRedirected ? "" : "\x1b[93m";
        public static string BRIGHT_BLUE = Console.IsOutputRedirected ? "" : "\x1b[94m";
        public static string BRIGHT_MAGENTA = Console.IsOutputRedirected ? "" : "\x1b[95m";
        public static string BRIGHT_CYAN = Console.IsOutputRedirected ? "" : "\x1b[96m";
        public static string BRIGHT_WHITE = Console.IsOutputRedirected ? "" : "\x1b[97m";
        public static string BLACK_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[40m";
        public static string RED_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[41m";
        public static string GREEN_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[42m";
        public static string YELLOW_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[43m";
        public static string BLUE_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[44m";
        public static string MAGENTA_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[45m";
        public static string CYAN_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[46m";
        public static string WHITE_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[47m";
        public static string BRIGHT_BLACK_BACKGROUND = Console.IsOutputRedirected
            ? ""
            : "\x1b[100m";
        public static string BRIGHT_RED_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[101m";
        public static string BRIGHT_GREEN_BACKGROUND = Console.IsOutputRedirected
            ? ""
            : "\x1b[102m";
        public static string BRIGHT_YELLOW_BACKGROUND = Console.IsOutputRedirected
            ? ""
            : "\x1b[103m";
        public static string BRIGHT_BLUE_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[104m";
        public static string BRIGHT_MAGENTA_BACKGROUND = Console.IsOutputRedirected
            ? ""
            : "\x1b[105m";
        public static string BRIGHT_CYAN_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[106m";
        public static string BRIGHT_WHITE_BACKGROUND = Console.IsOutputRedirected
            ? ""
            : "\x1b[107m";
        #endregion

        #region AutoGenFunctions
        public static string Black(object source) =&gt; BLACK + source.ToString() + NORMAL;

        public static string Red(object source) =&gt; RED + source.ToString() + NORMAL;

        public static string Green(object source) =&gt; GREEN + source.ToString() + NORMAL;

        public static string Yellow(object source) =&gt; YELLOW + source.ToString() + NORMAL;

        public static string Blue(object source) =&gt; BLUE + source.ToString() + NORMAL;

        public static string Magenta(object source) =&gt; MAGENTA + source.ToString() + NORMAL;

        public static string Cyan(object source) =&gt; CYAN + source.ToString() + NORMAL;

        public static string White(object source) =&gt; WHITE + source.ToString() + NORMAL;

        public static string BrightBlack(object source) =&gt;
            BRIGHT_BLACK + source.ToString() + NORMAL;

        public static string BrightRed(object source) =&gt; BRIGHT_RED + source.ToString() + NORMAL;

        public static string BrightGreen(object source) =&gt;
            BRIGHT_GREEN + source.ToString() + NORMAL;

        public static string BrightYellow(object source) =&gt;
            BRIGHT_YELLOW + source.ToString() + NORMAL;

        public static string BrightBlue(object source) =&gt; BRIGHT_BLUE + source.ToString() + NORMAL;

        public static string BrightMagenta(object source) =&gt;
            BRIGHT_MAGENTA + source.ToString() + NORMAL;

        public static string BrightCyan(object source) =&gt; BRIGHT_CYAN + source.ToString() + NORMAL;

        public static string BrightWhite(object source) =&gt;
            BRIGHT_WHITE + source.ToString() + NORMAL;

        public static string BlackBackground(object source) =&gt;
            BLACK_BACKGROUND + source.ToString() + NORMAL;

        public static string RedBackground(object source) =&gt;
            RED_BACKGROUND + source.ToString() + NORMAL;

        public static string GreenBackground(object source) =&gt;
            GREEN_BACKGROUND + source.ToString() + NORMAL;

        public static string YellowBackground(object source) =&gt;
            YELLOW_BACKGROUND + source.ToString() + NORMAL;

        public static string BlueBackground(object source) =&gt;
            BLUE_BACKGROUND + source.ToString() + NORMAL;

        public static string MagentaBackground(object source) =&gt;
            MAGENTA_BACKGROUND + source.ToString() + NORMAL;

        public static string CyanBackground(object source) =&gt;
            CYAN_BACKGROUND + source.ToString() + NORMAL;

        public static string WhiteBackground(object source) =&gt;
            WHITE_BACKGROUND + source.ToString() + NORMAL;

        public static string BrightBlackBackground(object source) =&gt;
            BRIGHT_BLACK_BACKGROUND + source.ToString() + NORMAL;

        public static string BrightRedBackground(object source) =&gt;
            BRIGHT_RED_BACKGROUND + source.ToString() + NORMAL;

        public static string BrightGreenBackground(object source) =&gt;
            BRIGHT_GREEN_BACKGROUND + source.ToString() + NORMAL;

        public static string BrightYellowBackground(object source) =&gt;
            BRIGHT_YELLOW_BACKGROUND + source.ToString() + NORMAL;

        public static string BrightBlueBackground(object source) =&gt;
            BRIGHT_BLUE_BACKGROUND + source.ToString() + NORMAL;

        public static string BrightMagentaBackground(object source) =&gt;
            BRIGHT_MAGENTA_BACKGROUND + source.ToString() + NORMAL;

        public static string BrightCyanBackground(object source) =&gt;
            BRIGHT_CYAN_BACKGROUND + source.ToString() + NORMAL;

        public static string BrightWhiteBackground(object source) =&gt;
            BRIGHT_WHITE_BACKGROUND + source.ToString() + NORMAL;
        #endregion

        #region Functions
        public static string Surround(string source, string surroundValue)
        {
            return surroundValue + source + NORMAL;
        }
        #endregion
    }
}
]]></description><link>api\misc\logger.cs.html</link><guid isPermaLink="false">API/Misc/Logger.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[MathMisc.cs]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Misc
{
    public class MathMisc
    {
        public static float PI = (float)Math.PI;

        public static float Cosf(double degrees) =&gt; (float)Math.Cos(degrees * Math.PI / 180f);

        public static float Sinf(double degrees) =&gt; (float)Math.Sin(degrees * Math.PI / 180f);

        public static float Atan2f(double x, double y) =&gt;
            (float)Math.Atan2(x * Math.PI / 180f, y * Math.PI / 180f);

        public static float Asinf(double degrees) =&gt; (float)Math.Asin(degrees * Math.PI / 180f);

        public static float Atan2fRad(double x, double y) =&gt; (float)Math.Atan2(x, y);

        public static float AsinfRad(double x) =&gt; (float)Math.Asin(x);

        public static float CosfRad(double x) =&gt; (float)Math.Cos(x);

        public static float SinfRad(double x) =&gt; (float)Math.Sin(x);
    }
}
]]></description><link>api\misc\mathmisc.cs.html</link><guid isPermaLink="false">API/Misc/MathMisc.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[RenderMisc.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Textures;
using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Misc
{
    public class RenderMisc
    {
        public static Vector2[] DefaultTextureCoordinates
        {
            get
            {
                return
                [
                    new Vector2(0f, 1f),
                    new Vector2(1f, 1f),
                    new Vector2(0f, 0f),
                    new Vector2(1f, 0f),
                ];
            }
        }

        public static Texture GetScreenTexture()
        {
            int[] k = new int[4];

            GL.GetInteger(GetIndexedPName.Viewport, 0, k);

            Vector2i size = new(k[2], k[3]);

            byte[] output = new byte[
                4 *
                size.X *
                size.Y
            ];

            unsafe
            {
                fixed (byte* outputPtr = output)
                {
                    GL.ReadPixels(
                        0,
                        0,
                        size.X,
                        size.Y,
                        PixelFormat.Rgba,
                        PixelType.UnsignedByte,
                        (IntPtr)outputPtr
                    );
                }
            }

            Texture tex = Texture.LoadFromBytes(output, k[2], k[3]);

            return tex;
        }
    }
}
]]></description><link>api\misc\rendermisc.cs.html</link><guid isPermaLink="false">API/Misc/RenderMisc.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[Cube.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering.Geometries
{
    internal class Cube : Geometry3D
    {
        public Vector3 shape { get; private set; }

        public Cube(Vector3 shape)
        {
            this.shape = shape;
            Init();
        }

        private void Init()
        {
            (this.Vertices, this.Normals, this.TexCoords, this.Indices) = GetCube();
        }

        private (
            Vector3[] vertices,
            Vector3[] normals,
            Vector2[] texCoords,
            uint[] indices
        ) GetCube()
        {
            List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();
            List&lt;Vector3&gt; normals = new List&lt;Vector3&gt;();
            List&lt;Vector2&gt; texCoords = new List&lt;Vector2&gt;();
            List&lt;uint&gt; indices = new List&lt;uint&gt;();
            float x = shape.X;
            float y = shape.Y;
            float z = shape.Z;

            float xOffset = shape.X / 2f;
            float yOffset = shape.Y / 2f;
            float zOffset = shape.Z / 2f;

            Square front = new Square(new Vector2(x, y));
            Square back = new Square(new Vector2(x, y));
            Square left = new Square(new Vector2(z, y));
            Square right = new Square(new Vector2(z, y));
            Square top = new Square(new Vector2(x, z));
            Square bottom = new Square(new Vector2(x, z));

            Transform dummy = new Transform();
            dummy.Position.Z = -zOffset; // front
            dummy.Rotation.Z = 180;
            dummy.UpdateMatrix();
            front.ApplyTransformation(dummy.GetModelMatrix());
            dummy.Reset();

            dummy.Position.Z = zOffset;
            dummy.UpdateMatrix();
            back.ApplyTransformation(dummy.GetModelMatrix());
            dummy.Reset();

            dummy.Position.X = -xOffset;
            dummy.Rotation.Z = -90;
            dummy.UpdateMatrix();
            left.ApplyTransformation(dummy.GetModelMatrix());
            dummy.Reset();

            dummy.Position.X = xOffset;
            dummy.Rotation.Z = 90;
            dummy.UpdateMatrix();
            right.ApplyTransformation(dummy.GetModelMatrix());
            dummy.Reset();

            dummy.Position.Y = yOffset;
            dummy.Rotation.Y = -90;
            dummy.UpdateMatrix();
            top.ApplyTransformation(dummy.GetModelMatrix());
            dummy.Reset();

            dummy.Position.Y = -yOffset;
            dummy.Rotation.Y = 90;
            dummy.UpdateMatrix();
            bottom.ApplyTransformation(dummy.GetModelMatrix());

            MergedGeometry merged = Geometry3D.MergeGeometries(
                [front, back, left, right, top, bottom]
            );

            vertices.AddRange(merged.Vertices);
            normals.AddRange(merged.Normals);
            texCoords.AddRange(merged.TexCoords);
            indices.AddRange(merged.Indices);

            return (vertices.ToArray(), normals.ToArray(), texCoords.ToArray(), indices.ToArray());
        }
    }
}
]]></description><link>api\rendering\geometries\cube.cs.html</link><guid isPermaLink="false">API/Rendering/Geometries/Cube.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[Cylinder.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;
using OpenglTestConsole.Classes.API.Rendering.MeshClasses;
using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering.Geometries
{
    public class Cylinder : Geometry3D
    {
        private int StackCount;
        private int SectorCount;
        private float Height;
        private float Radius;

        // its not that hard to draw a FUCKİNG CYLİNDER
        // YOU NEED TO DRAW A CİRCLE
        // sin cos gives dot from angle
        // then you star from angle 0, then increase it by 360/sector count

        public Cylinder(int StackCount, int SectorCount, float Height, float Radius)
        {
            this.StackCount = StackCount;
            this.SectorCount = SectorCount;
            this.Height = Height;
            this.Radius = Radius;
            Init();
        }

        private void Init()
        {
            (this.Vertices, this.Normals, this.TexCoords, this.Indices) = GetCylinder();
        }

        public override void Apply(BufferManager BufferManager)
        {
            BufferManager.SetVector3(Vertices, 0);
            BufferManager.SetVector3(Normals, 1);
            BufferManager.SetVector2(TexCoords, 2);
            BufferManager.SetIndices(Indices);
        }

        private (
            Vector3[] vertices,
            Vector3[] normals,
            Vector2[] texCoords,
            uint[] indices
        ) GetCylinder()
        {
            List&lt;Vector3&gt; unitVertices = GetUnitVertices(SectorCount);

            List&lt;Vector3&gt; vertices = new();
            List&lt;Vector3&gt; normals = new();
            List&lt;Vector2&gt; texCoords = new();

            // put side vertices to arrays
            for (int i = 0; i &lt;= StackCount; i++)
            {
                float stackStep = Height / StackCount;
                float h = -Height / 2.0f + i * stackStep;
                // t goes from 1.0 down to 0.0 as i goes from 0 to StackCount
                float t = 1.0f - (float)i / StackCount;

                for (int j = 0; j &lt; SectorCount; j++)
                {
                    Vector3 unit = unitVertices[j];

                    vertices.Add(
                        new(
                            unit.X * Radius, // vx
                            unit.Y * Radius, // vy
                            h // vz
                        )
                    );

                    // normal vector
                    normals.Add(
                        new(
                            unit.X, // nx
                            unit.Y, // ny
                            unit.Z // nz
                        )
                    );

                    // texture coordinate
                    texCoords.Add(
                        new(
                            (float)(j / (float)SectorCount), // s
                            t // t
                        )
                    );
                }
            }

            #region top and bottom vertices
            // bottom Center point
            float lidHeight = -(Height / 2f);
            float nz = -1;
            vertices.Add(new Vector3(0, 0, lidHeight));
            normals.Add(new Vector3(0, 0, nz));
            texCoords.Add(new Vector2(0.5f, 0.5f));

            // top center point
            lidHeight = Height / 2f;
            nz = -1;
            vertices.Add(new Vector3(0, 0, lidHeight));
            normals.Add(new Vector3(0, 0, nz));
            texCoords.Add(new Vector2(0.5f, 0.5f));
            #endregion

            List&lt;uint&gt; indices = new List&lt;uint&gt;();
            uint uintSectorCount = Convert.ToUInt32(SectorCount);
            uint uintStackCount = Convert.ToUInt32(StackCount);

            #region side indices

            for (uint i = 0; i &lt; StackCount; ++i)
            {
                uint k1 = i * uintSectorCount; // beginning of current stack
                uint k2 = k1 + uintSectorCount; // beginning of next stack

                for (int j = 0; j &lt; SectorCount; j++, ++k1, ++k2)
                {
                    // First triangle of quad
                    indices.Add(k1);
                    indices.Add(k1 + 1);
                    indices.Add(k2);

                    // 0 2 5
                    // Second triangle of quad
                    if (j + 1 != SectorCount)
                    { // normal stuff
                        indices.Add(k2); // 5
                        indices.Add(k1 + 1); // 3
                        indices.Add(k2 + 1); // 6
                    }
                    else
                    { // we need 3 0 and 2
                        indices.Add(k1); // 2
                        indices.Add(uintSectorCount * i); // 0
                        indices.Add(k1 + 1); // 3
                        //indices.Add(Math.Min(k1 - uintSectorCount, 0));
                        //indices.Add((uintSectorCount * i));
                    }
                }
            }

            #endregion

            #region top and bottom indices

            #region top

            uint bottomIndex = (uint)(vertices.Count - 2); // bottom center point
            uint bottomK1 = 0;
            uint bottomK2 = 1;

            for (int j = 0; j &lt; SectorCount; j++, bottomK1++, bottomK2++)
            {
                // First triangle
                // 3 is the next stacks starting index, which is the number of sectors we have
                // so it not being 3 means we are in the same stack
                if (bottomK2 != SectorCount)
                    indices.Add(bottomK2);
                else
                    indices.Add(bottomK2 - uintSectorCount); // 0
                indices.Add(bottomK1);
                indices.Add(bottomIndex); // center point
            }

            #endregion

            #region bottom

            uint topIndex = (uint)(vertices.Count - 1); // top center point
            uint topK1 = uintSectorCount * uintStackCount; // beginning of current stack
            uint topK2 = topK1 + 1; // beginning of next stack

            for (int j = 0; j &lt; SectorCount; j++, topK1++, topK2++)
            {
                // First triangle of quad
                indices.Add(topIndex); // center point
                indices.Add(topK1);
                // 3 is the next stacks starting index, which is the number of sectors we have
                // so it not being 3 means we are in the same stack
                if (topK2 != vertices.Count - 2)
                    indices.Add(topK2);
                else
                    indices.Add(uintSectorCount * uintStackCount); // 0
            }

            #endregion

            #endregion

            return (vertices.ToArray(), normals.ToArray(), texCoords.ToArray(), indices.ToArray());
        }

        private List&lt;Vector3&gt; GetUnitVertices(int sectorCount)
        {
            List&lt;Vector3&gt; unitVertices = new();
            for (int i = 0; i &lt; sectorCount; i++)
            {
                float currentAngle = i * (360f / sectorCount); // current angle in degrees

                float x = MathMisc.Cosf(currentAngle);
                float y = MathMisc.Sinf(currentAngle);

                unitVertices.Add(new(x, y, 0));
            }

            return unitVertices;
        }
    }
}
]]></description><link>api\rendering\geometries\cylinder.cs.html</link><guid isPermaLink="false">API/Rendering/Geometries/Cylinder.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[Geometry3D.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.MeshClasses;
using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering.Geometries
{
    public abstract class Geometry3D
    {
        public int size;
        #region length
        public int IndicesLength { get =&gt; this.Indices.Length; }
        public int VerticesLength { get =&gt; this.Vertices.Length; }
        public int NormalsLength { get =&gt; this.Normals.Length; }
        public int TexCoordsLength { get =&gt; this.TexCoords.Length; }
        #endregion

        public uint[] Indices = [];

        public Vector3[] Vertices = Array.Empty&lt;Vector3&gt;();
        public Vector3[] Normals = Array.Empty&lt;Vector3&gt;();
        public Vector2[] TexCoords = Array.Empty&lt;Vector2&gt;();

        public virtual void Apply(BufferManager BufferManager)
        {
            size = this.VerticesLength; // almost forgor this lmao
            BufferManager.SetVector3(this.Vertices, 0);
            BufferManager.SetVector3(this.Normals, 1);
            BufferManager.SetVector2(this.TexCoords, 2);
            BufferManager.SetIndices(this.Indices);
        }

        public void ApplyTransformation(Matrix4 transform)
        {
            // Transform vertex positions
            for (int i = 0; i &lt; Vertices.Length; i++)
            {
                Vertices[i] = Vector3.TransformPosition(Vertices[i], transform);
            }

            // Transform normals (ignore translation)
            for (int i = 0; i &lt; Normals.Length; i++)
            {
                Normals[i] = Vector3.TransformNormal(Normals[i], transform);
                Normals[i] = Normals[i].Normalized();
            }
        }

        public static MergedGeometry MergeGeometries(Geometry3D[] geometries)
        {
            MergedGeometry mergedGeometry = new MergedGeometry();
            List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();
            List&lt;Vector3&gt; normals = new List&lt;Vector3&gt;();
            List&lt;Vector2&gt; texCoords = new List&lt;Vector2&gt;();
            List&lt;uint&gt; indices = new List&lt;uint&gt;();
            uint indexOffset = 0;
            foreach (var geometry in geometries)
            {
                vertices.AddRange(geometry.Vertices);
                normals.AddRange(geometry.Normals);
                texCoords.AddRange(geometry.TexCoords);
                indices.AddRange(geometry.Indices.Select(i =&gt; i + indexOffset));
                indexOffset += (uint)geometry.Vertices.Length;
            }
            mergedGeometry.Vertices = vertices.ToArray();
            mergedGeometry.Normals = normals.ToArray();
            mergedGeometry.TexCoords = texCoords.ToArray();
            mergedGeometry.Indices = indices.ToArray();
            return mergedGeometry;
        }
    }
}
]]></description><link>api\rendering\geometries\geometry3d.cs.html</link><guid isPermaLink="false">API/Rendering/Geometries/Geometry3D.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[MergedGeometry.cs]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Rendering.Geometries
{
    public class MergedGeometry : Geometry3D
    {
        public MergedGeometry() { }
    }
}
]]></description><link>api\rendering\geometries\mergedgeometry.cs.html</link><guid isPermaLink="false">API/Rendering/Geometries/MergedGeometry.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[Skybox.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenglTestConsole.Classes.API.Rendering.Geometries
{
    public class Skybox : Geometry3D
    {
        public Skybox()
        {
            Init();
        }
        private void Init()
        {
            (this.Vertices, this.Normals, this.TexCoords, this.Indices) = GetSkybox();
        }

        private (
            Vector3[] vertices,
            Vector3[] normals,
            Vector2[] texCoords,
            uint[] indices
        ) GetSkybox()
        {
            return (
                vertices:
                [
                    new(-1.0f,  1.0f, -1.0f),
                    new(-1.0f, -1.0f, -1.0f),
                    new( 1.0f, -1.0f, -1.0f),
                    new( 1.0f, -1.0f, -1.0f),
                    new( 1.0f,  1.0f, -1.0f),
                    new(-1.0f,  1.0f, -1.0f),

                    new(-1.0f, -1.0f,  1.0f),
                    new(-1.0f, -1.0f, -1.0f),
                    new(-1.0f,  1.0f, -1.0f),
                    new(-1.0f,  1.0f, -1.0f),
                    new(-1.0f,  1.0f,  1.0f),
                    new(-1.0f, -1.0f,  1.0f),

                    new( 1.0f, -1.0f, -1.0f),
                    new( 1.0f, -1.0f,  1.0f),
                    new( 1.0f,  1.0f,  1.0f),
                    new( 1.0f,  1.0f,  1.0f),
                    new( 1.0f,  1.0f, -1.0f),
                    new( 1.0f, -1.0f, -1.0f),

                    new(-1.0f, -1.0f,  1.0f),
                    new(-1.0f,  1.0f,  1.0f),
                    new( 1.0f,  1.0f,  1.0f),
                    new( 1.0f,  1.0f,  1.0f),
                    new( 1.0f, -1.0f,  1.0f),
                    new(-1.0f, -1.0f,  1.0f),

                    new(-1.0f,  1.0f, -1.0f),
                    new( 1.0f,  1.0f, -1.0f),
                    new( 1.0f,  1.0f,  1.0f),
                    new( 1.0f,  1.0f,  1.0f),
                    new(-1.0f,  1.0f,  1.0f),
                    new(-1.0f,  1.0f, -1.0f),

                    new(-1.0f, -1.0f, -1.0f),
                    new(-1.0f, -1.0f,  1.0f),
                    new( 1.0f, -1.0f, -1.0f),
                    new( 1.0f, -1.0f, -1.0f),
                    new(-1.0f, -1.0f,  1.0f),
                    new( 1.0f, -1.0f,  1.0f)
                ],
                normals: [],
                texCoords: [], // same as the vertex positions
                indices: []
                );
        }
    }
}
]]></description><link>api\rendering\geometries\skybox.cs.html</link><guid isPermaLink="false">API/Rendering/Geometries/Skybox.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[Sphere.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;
using OpenglTestConsole.Classes.API.Rendering.MeshClasses;
using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering.Geometries
{
    public class Sphere : Geometry3D
    {
        public int SectorCount;
        public int StackCount;
        public float radius;

        public Sphere(int stackCount, int sectorCount, float radius)
        {
            this.StackCount = stackCount;
            this.SectorCount = sectorCount;
            this.radius = radius;
            Init();
        }

        private void Init()
        {
            (this.Vertices, this.Normals, this.TexCoords, this.Indices, _) = GetSphere();
            Transform tempTrans = new Transform();
            tempTrans.Rotation.Y = -90;
            tempTrans.UpdateMatrix();
            this.ApplyTransformation(tempTrans.GetModelMatrix());
        }

        public (
            Vector3[] vertices,
            Vector3[] normals,
            Vector2[] texCoords,
            uint[] indices,
            uint[] lineIndices
        ) GetSphere()
        {
            // make variables for quick access as we are using floats and all deez are returning doubles

            // list because itd be annoying to use arrays from the start
            List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();
            List&lt;Vector3&gt; normals = new List&lt;Vector3&gt;();
            List&lt;Vector2&gt; texCoords = new List&lt;Vector2&gt;();

            float lengthInv = 1.0f / radius;
            float sectorStep = 2 * MathMisc.PI / SectorCount;
            float stackStep = MathMisc.PI / StackCount;

            for (int i = 0; i &lt;= StackCount; i++)
            {
                float stackAngle = MathMisc.PI / 2 - i * stackStep; // starting from pi/2 to -pi/2
                float xy = radius * MathMisc.CosfRad(stackAngle); // r * cos(u)
                float z = radius * MathMisc.SinfRad(stackAngle); // r * sin(u)

                for (int j = 0; j &lt;= SectorCount; j++)
                {
                    float sectorAngle = j * sectorStep; // starting from 0 to 2pi

                    // vertex position (x, y, z)
                    float x = xy * MathMisc.CosfRad(sectorAngle); // r * cos(u) * cos(v)
                    float y = xy * MathMisc.SinfRad(sectorAngle); // r * cos(u) * sin(v)
                    vertices.Add(new Vector3(x, y, z));

                    float normalisedX = x * lengthInv;
                    float normalisedY = y * lengthInv;
                    float normalisedZ = z * lengthInv;
                    normals.Add(new Vector3(normalisedX, normalisedY, normalisedZ));

                    // vertex tex coord (s, t) range between [0, 1]
                    float s = (float)j / SectorCount;
                    float t = (float)i / StackCount;
                    texCoords.Add(new Vector2(s, t));
                }
            }

            // generate CCW index list of sphere triangles
            // k1--k1+1
            // |  / |
            // | /  |
            // k2--k2+1
            List&lt;uint&gt; indices = new List&lt;uint&gt;();
            List&lt;uint&gt; lineIndices = new List&lt;uint&gt;(); // for wireframe and blabla
            for (int i = 0; i &lt; StackCount; ++i)
            {
                uint k1 = (uint)(i * (SectorCount + 1)); // beginning of current stack
                uint k2 = (uint)(k1 + SectorCount + 1); // beginning of next stack

                for (int j = 0; j &lt; SectorCount; ++j, ++k1, ++k2)
                {
                    // 2 triangles per sector excluding first and last stacks
                    // k1 =&gt; k2 =&gt; k1+1
                    if (i != 0)
                    {
                        indices.Add(k1);
                        indices.Add(k2);
                        indices.Add(k1 + 1);
                    }

                    // k1+1 =&gt; k2 =&gt; k2+1
                    if (i != StackCount - 1)
                    {
                        indices.Add(k1 + 1);
                        indices.Add(k2);
                        indices.Add(k2 + 1);
                    }

                    // store indices for lines
                    // vertical lines for all stacks, k1 =&gt; k2
                    lineIndices.Add(k1);
                    lineIndices.Add(k2);
                    if (i != 0) // horizontal lines except 1st stack, k1 =&gt; k+1
                    {
                        lineIndices.Add(k1);
                        lineIndices.Add(k1 + 1);
                    }
                }
            }

            return (
                vertices: vertices.ToArray(),
                normals: normals.ToArray(),
                texCoords: texCoords.ToArray(),
                indices: indices.ToArray(),
                lineIndices: lineIndices.ToArray()
            );
        }

        public override void Apply(BufferManager BufferManager)
        {
            base.Apply(BufferManager);
        }
    }
}
]]></description><link>api\rendering\geometries\sphere.cs.html</link><guid isPermaLink="false">API/Rendering/Geometries/Sphere.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[Square.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering.Geometries
{
    internal class Square : Geometry3D
    {
        public Vector2 shape { get; private set; }

        public Square(Vector2 shape)
        {
            this.shape = shape;
            Init();
        }

        private void Init()
        {
            (this.Vertices, this.Normals, this.TexCoords, this.Indices) = GetPlane();
        }

        public (
            Vector3[] vertices,
            Vector3[] normals,
            Vector2[] texCoords,
            uint[] indices
        ) GetPlane()
        {
            // make variables for quick access as we are using floats and all deez are returning doubles
            // list because itd be annoying to use arrays from the start
            List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();
            List&lt;Vector3&gt; normals = new List&lt;Vector3&gt;();
            List&lt;Vector2&gt; texCoords = new List&lt;Vector2&gt;();
            float x = shape.X / 2f;
            float y = shape.Y / 2f;
            vertices.Add(new Vector3(-x, -y, 0));
            vertices.Add(new Vector3(x, -y, 0));
            vertices.Add(new Vector3(x, y, 0));
            vertices.Add(new Vector3(-x, y, 0));

            normals.Add(new Vector3(0, 0, 1));
            normals.Add(new Vector3(0, 0, 1));
            normals.Add(new Vector3(0, 0, 1));
            normals.Add(new Vector3(0, 0, 1));

            texCoords.Add(new Vector2(0, 0));
            texCoords.Add(new Vector2(1, 0));
            texCoords.Add(new Vector2(1, 1));
            texCoords.Add(new Vector2(0, 1));

            return (
                vertices.ToArray(),
                normals.ToArray(),
                texCoords.ToArray(),
                new uint[] {
                    0, 1, 2,
                    2, 3, 0
                }
            );
        }
    }
}
]]></description><link>api\rendering\geometries\square.cs.html</link><guid isPermaLink="false">API/Rendering/Geometries/Square.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[PhongMaterials.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering.Materials
{
    public partial class PhongMaterial
    {
        #region pre made materials
        public static PhongMaterial Emerald =&gt;
            new PhongMaterial(
                new Vector3(0.0215f, 0.1745f, 0.0215f),
                new Vector3(0.07568f, 0.61424f, 0.07568f),
                new Vector3(0.633f, 0.727811f, 0.633f),
                0.6f
            );
        public static PhongMaterial Jade =&gt;
            new PhongMaterial(
                new Vector3(0.135f, 0.2225f, 0.1575f),
                new Vector3(0.54f, 0.89f, 0.63f),
                new Vector3(0.316228f, 0.316228f, 0.316228f),
                0.1f
            );
        public static PhongMaterial Obsidian =&gt;
            new PhongMaterial(
                new Vector3(0.05375f, 0.05f, 0.06625f),
                new Vector3(0.18275f, 0.17f, 0.22525f),
                new Vector3(0.332741f, 0.328634f, 0.346435f),
                0.3f
            );
        public static PhongMaterial Pearl =&gt;
            new PhongMaterial(
                new Vector3(0.25f, 0.20725f, 0.20725f),
                new Vector3(1f, 0.829f, 0.829f),
                new Vector3(0.296648f, 0.296648f, 0.296648f),
                0.088f
            );
        public static PhongMaterial Ruby =&gt;
            new PhongMaterial(
                new Vector3(0.1745f, 0.01175f, 0.01175f),
                new Vector3(0.61424f, 0.04136f, 0.04136f),
                new Vector3(0.727811f, 0.626959f, 0.626959f),
                0.6f
            );
        public static PhongMaterial Turquoise =&gt;
            new PhongMaterial(
                new Vector3(0.1f, 0.18725f, 0.1745f),
                new Vector3(0.396f, 0.74151f, 0.69102f),
                new Vector3(0.297254f, 0.30829f, 0.306678f),
                0.1f
            );
        public static PhongMaterial Brass =&gt;
            new PhongMaterial(
                new Vector3(0.329412f, 0.223529f, 0.027451f),
                new Vector3(0.780392f, 0.568627f, 0.113725f),
                new Vector3(0.992157f, 0.941176f, 0.807843f),
                0.21794872f
            );
        public static PhongMaterial Bronze =&gt;
            new PhongMaterial(
                new Vector3(0.2125f, 0.1275f, 0.054f),
                new Vector3(0.714f, 0.4284f, 0.18144f),
                new Vector3(0.393548f, 0.271906f, 0.166721f),
                0.2f
            );
        public static PhongMaterial Chrome =&gt;
            new PhongMaterial(
                new Vector3(0.25f, 0.25f, 0.25f),
                new Vector3(0.4f, 0.4f, 0.4f),
                new Vector3(0.774597f, 0.774597f, 0.774597f),
                0.6f
            );
        public static PhongMaterial Copper =&gt;
            new PhongMaterial(
                new Vector3(0.19125f, 0.0735f, 0.0225f),
                new Vector3(0.7038f, 0.27048f, 0.0828f),
                new Vector3(0.256777f, 0.137622f, 0.086014f),
                0.1f
            );
        public static PhongMaterial Gold =&gt;
            new PhongMaterial(
                new Vector3(0.24725f, 0.1995f, 0.0745f),
                new Vector3(0.75164f, 0.60648f, 0.22648f),
                new Vector3(0.628281f, 0.555802f, 0.366065f),
                0.4f
            );
        public static PhongMaterial Silver =&gt;
            new PhongMaterial(
                new Vector3(0.19225f, 0.19225f, 0.19225f),
                new Vector3(0.50754f, 0.50754f, 0.50754f),
                new Vector3(0.508273f, 0.508273f, 0.508273f),
                0.4f
            );
        public static PhongMaterial BlackPlastic =&gt;
            new PhongMaterial(
                new Vector3(0f, 0f, 0f),
                new Vector3(0.01f, 0.01f, 0.01f),
                new Vector3(0.5f, 0.5f, 0.5f),
                0.25f
            );
        public static PhongMaterial CyanPlastic =&gt;
            new PhongMaterial(
                new Vector3(0f, 0.1f, 0.06f),
                new Vector3(0f, 0.50980392f, 0.50980392f),
                new Vector3(0.50196078f, 0.50196078f, 0.50196078f),
                0.25f
            );
        public static PhongMaterial GreenPlastic =&gt;
            new PhongMaterial(
                new Vector3(0f, 0f, 0f),
                new Vector3(0.1f, 0.35f, 0.1f),
                new Vector3(0.45f, 0.55f, 0.45f),
                0.25f
            );
        public static PhongMaterial RedPlastic =&gt;
            new PhongMaterial(
                new Vector3(0f, 0f, 0f),
                new Vector3(0.5f, 0f, 0f),
                new Vector3(0.7f, 0.6f, 0.6f),
                0.25f
            );
        public static PhongMaterial WhitePlastic =&gt;
            new PhongMaterial(
                new Vector3(0f, 0f, 0f),
                new Vector3(0.55f, 0.55f, 0.55f),
                new Vector3(0.7f, 0.7f, 0.7f),
                0.25f
            );
        public static PhongMaterial YellowPlastic =&gt;
            new PhongMaterial(
                new Vector3(0f, 0f, 0f),
                new Vector3(0.5f, 0.5f, 0f),
                new Vector3(0.6f, 0.6f, 0.5f),
                0.25f
            );
        public static PhongMaterial BlackRubber =&gt;
            new PhongMaterial(
                new Vector3(0.02f, 0.02f, 0.02f),
                new Vector3(0.01f, 0.01f, 0.01f),
                new Vector3(0.4f, 0.4f, 0.4f),
                0.078125f
            );
        public static PhongMaterial CyanRubber =&gt;
            new PhongMaterial(
                new Vector3(0f, 0.05f, 0.05f),
                new Vector3(0.4f, 0.5f, 0.5f),
                new Vector3(0.04f, 0.7f, 0.7f),
                0.078125f
            );
        public static PhongMaterial GreenRubber =&gt;
            new PhongMaterial(
                new Vector3(0f, 0.05f, 0f),
                new Vector3(0.4f, 0.5f, 0.4f),
                new Vector3(0.04f, 0.7f, 0.04f),
                0.078125f
            );
        public static PhongMaterial RedRubber =&gt;
            new PhongMaterial(
                new Vector3(0.05f, 0f, 0f),
                new Vector3(0.5f, 0.4f, 0.4f),
                new Vector3(0.7f, 0.04f, 0.04f),
                0.078125f
            );
        public static PhongMaterial WhiteRubber =&gt;
            new PhongMaterial(
                new Vector3(0.05f, 0.05f, 0.05f),
                new Vector3(0.5f, 0.5f, 0.5f),
                new Vector3(0.7f, 0.7f, 0.7f),
                0.078125f
            );
        public static PhongMaterial YellowRubber =&gt;
            new PhongMaterial(
                new Vector3(0.05f, 0.05f, 0f),
                new Vector3(0.5f, 0.5f, 0.4f),
                new Vector3(0.7f, 0.7f, 0.04f),
                0.078125f
            );

        #endregion
    }
}
]]></description><link>api\rendering\materials\predefinedmaterials\phongmaterials.cs.html</link><guid isPermaLink="false">API/Rendering/Materials/PreDefinedMaterials/PhongMaterials.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:30 GMT</pubDate></item><item><title><![CDATA[MonoColorMaterial.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;
using OpenglTestConsole.Generated.Paths;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenglTestConsole.Classes.API.Rendering.Materials
{
    internal class MonoColorMaterial : Material
    {
        public Vector4 color = new(1);
        public MonoColorMaterial(Vector4 col)
        {
            this.color = col;
            this.Shader = Resources.Shaders[ResourcePaths.Materials.MonoColor.Name];
        }
        public override void Apply()
        {
            Shader.UniformManager.SetVector4("color", color);
        }
    }
}
]]></description><link>api\rendering\materials\monocolormaterial.cs.html</link><guid isPermaLink="false">API/Rendering/Materials/MonoColorMaterial.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[PhongMaterial.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;
using OpenTK.Mathematics;
using OpenglTestConsole.Generated.Paths;

namespace OpenglTestConsole.Classes.API.Rendering.Materials
{
    public partial class PhongMaterial : Material
    {
        // color of the ambient lightning
        public Vector3 Ambient { get; set; }

        // color of the diffuse lightning
        public Vector3 Diffuse { get; set; }

        // color of the specular lightning
        public Vector3 Specular { get; set; }

        // size of the specular light
        public float Shininess { get; set; }

        public PhongMaterial()
        {
            this.Shader = Resources.Shaders[ResourcePaths.Materials.Phong.Name];
        }

        public PhongMaterial(Vector3 ambient, Vector3 diffuse, Vector3 specular, float shininess)
        {
            this.Ambient = ambient;
            this.Diffuse = diffuse;
            this.Specular = specular;
            this.Shininess = shininess * 128f;
            this.Shader = Resources.Shaders[ResourcePaths.Materials.Phong.Name];
        }

        public override void Apply()
        {
            Shader.UniformManager.SetVector3("material.ambient", Ambient);
            Shader.UniformManager.SetVector3("material.diffuse", Diffuse);
            Shader.UniformManager.SetVector3("material.specular", Specular);
            Shader.UniformManager.SetFloat("material.shininess", Shininess);

            // update this to allow more lights
            Shader.UniformManager.SetVector3("light.position", Scene.Lights[0].Position);
            Shader.UniformManager.SetVector3("light.specular", Scene.Lights[0].Specular);
            Shader.UniformManager.SetVector3("light.diffuse", Scene.Lights[0].Diffuse);
            Shader.UniformManager.SetVector3("light.ambient", Scene.Lights[0].Ambient);

            Shader.UniformManager.SetVector3("viewPos", Scene.Camera.Position);
        }
    }
}
]]></description><link>api\rendering\materials\phongmaterial.cs.html</link><guid isPermaLink="false">API/Rendering/Materials/PhongMaterial.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[SkyboxMaterial.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;
using OpenglTestConsole.Classes.API.Rendering.Textures;
using OpenglTestConsole.Generated.Paths;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenglTestConsole.Classes.API.Rendering.Materials
{
    internal class SkyboxMaterial : Material
    {
        private Cubemap cubemap;
        public SkyboxMaterial(Cubemap cubemap)
        {
            this.Shader = Resources.Shaders[ResourcePaths.Materials.Skybox.Name];
            this.cubemap = cubemap;
        }
        public override void Apply()
        { // set shader values here
            Shader.UniformManager.SetCubemap("skybox", cubemap, TextureUnit.Texture0);
        }
    }
}
]]></description><link>api\rendering\materials\skyboxmaterial.cs.html</link><guid isPermaLink="false">API/Rendering/Materials/SkyboxMaterial.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[StandartMaterial.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenglTestConsole.Classes.API.Rendering.Materials
{
    internal class StandartMaterial : Material
    {
        public bool Wireframe { get; set; }
        public bool FlatShaded { get; set; }

        public StandartMaterial() { }
        public override void Apply()
        {
            // add shader sets here

        }
    }
}
]]></description><link>api\rendering\materials\standartmaterial.cs.html</link><guid isPermaLink="false">API/Rendering/Materials/StandartMaterial.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[TextureMaterial.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;
using OpenTK.Mathematics;
using OpenglTestConsole.Generated.Paths;
using OpenglTestConsole.Classes.API.Rendering.Textures;

namespace OpenglTestConsole.Classes.API.Rendering.Materials
{
    public class TextureMaterial : Material
    {
        public Texture Texture { get; set; }
        public Vector4 Color { get; set; } = new Vector4(1f, 1f, 1f, 1f);
        public TextureMaterial() { this.Shader = Resources.Shaders[ResourcePaths.Materials.Texture.Name]; }
        public TextureMaterial(Texture texture, Vector4? color = null)
        {
            this.Texture = texture; this.Color = color ?? new Vector4(1f, 1f, 1f, 1f);
            this.Shader = Resources.Shaders[ResourcePaths.Materials.Texture.Name];
        }
        public override void Apply()
        {
            Shader.UniformManager.SetTexture("material.texture", Texture, TextureUnit.Texture0);
            Shader.UniformManager.SetVector4("material.colMultiplier", Color);
        }
    }
}
]]></description><link>api\rendering\materials\texturematerial.cs.html</link><guid isPermaLink="false">API/Rendering/Materials/TextureMaterial.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[BufferManager.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering.MeshClasses
{
    public partial class BufferManager
    {
        #region Shader
        private Dictionary&lt;int, int&gt; _vboCache = new(); // loc -&gt; VBO

        private int VertexArrayObjectPointer;
        private int _eboCache = -1; // Cache for the element buffer object (EBO)

        public BufferManager(int vao)
        {
            VertexArrayObjectPointer = vao;
        }

        public void SetVector2(
            Vector2[] vectors,
            int loc,
            BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
        )
        {
            GL.BindVertexArray(VertexArrayObjectPointer);

            if (!_vboCache.TryGetValue(loc, out int vbo))
            {
                vbo = GL.GenBuffer();
                _vboCache[loc] = vbo;

                GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
                GL.BufferData(
                    BufferTarget.ArrayBuffer,
                    vectors.Length * Vector2.SizeInBytes,
                    vectors,
                    bufferHint
                );

                GL.VertexAttribPointer(
                    loc,
                    2,
                    VertexAttribPointerType.Float,
                    false,
                    Vector2.SizeInBytes,
                    0
                );
                GL.EnableVertexAttribArray(loc);
            }
            else
            {
                GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
                GL.BufferSubData(
                    BufferTarget.ArrayBuffer,
                    IntPtr.Zero,
                    vectors.Length * Vector2.SizeInBytes,
                    vectors
                );
            }
        }

        public void SetVector3(
            Vector3[] vectors,
            int loc,
            BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
        )
        {
            GL.BindVertexArray(VertexArrayObjectPointer);

            if (!_vboCache.TryGetValue(loc, out int vbo))
            {
                vbo = GL.GenBuffer();
                _vboCache[loc] = vbo;

                GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
                GL.BufferData(
                    BufferTarget.ArrayBuffer,
                    vectors.Length * Vector3.SizeInBytes,
                    vectors,
                    bufferHint
                );

                GL.VertexAttribPointer(
                    loc,
                    3,
                    VertexAttribPointerType.Float,
                    false,
                    Vector3.SizeInBytes,
                    0
                );
                GL.EnableVertexAttribArray(loc);
            }
            else
            {
                GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
                GL.BufferSubData(
                    BufferTarget.ArrayBuffer,
                    IntPtr.Zero,
                    vectors.Length * Vector3.SizeInBytes,
                    vectors
                );
            }
        }

        public void SetVector4(
            Vector4[] vectors,
            int loc,
            BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
        )
        {
            GL.BindVertexArray(VertexArrayObjectPointer);

            if (!_vboCache.TryGetValue(loc, out int vbo))
            {
                vbo = GL.GenBuffer();
                _vboCache[loc] = vbo;

                GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
                GL.BufferData(
                    BufferTarget.ArrayBuffer,
                    vectors.Length * Vector4.SizeInBytes,
                    vectors,
                    bufferHint
                );

                GL.VertexAttribPointer(
                    loc,
                    4,
                    VertexAttribPointerType.Float,
                    false,
                    Vector4.SizeInBytes,
                    0
                );
                GL.EnableVertexAttribArray(loc);
            }
            else
            {
                GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
                GL.BufferSubData(
                    BufferTarget.ArrayBuffer,
                    IntPtr.Zero,
                    vectors.Length * Vector4.SizeInBytes,
                    vectors
                );
            }
        }

        public void SetColor(
            Color4[] colors,
            int loc,
            BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
        )
        {
            GL.BindVertexArray(VertexArrayObjectPointer);

            if (!_vboCache.TryGetValue(loc, out int vbo))
            {
                vbo = GL.GenBuffer();
                _vboCache[loc] = vbo;

                GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
                GL.BufferData(
                    BufferTarget.ArrayBuffer,
                    colors.Length * 4 * sizeof(float),
                    colors,
                    bufferHint
                );

                GL.VertexAttribPointer(
                    loc,
                    4,
                    VertexAttribPointerType.Float,
                    false,
                    4 * sizeof(float),
                    0
                );
                GL.EnableVertexAttribArray(loc);
            }
            else
            {
                GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
                GL.BufferSubData(
                    BufferTarget.ArrayBuffer,
                    IntPtr.Zero,
                    colors.Length * 4 * sizeof(float),
                    colors
                );
            }
        }

        public void SetIndices(
            uint[] indices,
            BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
        )
        {
            GL.BindVertexArray(VertexArrayObjectPointer);

            if (_eboCache == -1)
            {
                _eboCache = GL.GenBuffer();
                GL.BindBuffer(BufferTarget.ElementArrayBuffer, _eboCache);
                GL.BufferData(
                    BufferTarget.ElementArrayBuffer,
                    indices.Length * sizeof(uint),
                    indices,
                    bufferHint
                );
            }
            else
            {
                GL.BindBuffer(BufferTarget.ElementArrayBuffer, _eboCache);
                GL.BufferSubData(
                    BufferTarget.ElementArrayBuffer,
                    IntPtr.Zero,
                    indices.Length * sizeof(uint),
                    indices
                );
            }
        }

        public void Dispose()
        {
            // Delete all VBOs
            foreach (var vbo in _vboCache.Values)
            {
                GL.DeleteBuffer(vbo);
            }

            // Delete the EBO if it exists
            if (_eboCache != -1)
            {
                GL.DeleteBuffer(_eboCache);
            }

            // Clear the cache
            _vboCache.Clear();
            _eboCache = -1;
        }

        #endregion
    }
}
]]></description><link>api\rendering\meshclasses\buffermanager.cs.html</link><guid isPermaLink="false">API/Rendering/MeshClasses/BufferManager.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[InstancedMesh.cs]]></title><description><![CDATA[ 
 <br>using Newtonsoft.Json.Linq;
using OpenglTestConsole.Classes.API.Extensions;
using OpenglTestConsole.Classes.API.Rendering;
using OpenTK.Graphics.OpenGL;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace OpenglTestConsole.Classes.API.Rendering.MeshClasses
{
    public partial class InstancedMesh&lt;T&gt; where T : Mesh
    {
        public List&lt;T&gt; Meshes { get; set; } = new();
        public InstancedMesh() { }

        public void FinishAddingElemets()
        {
            Matrix4[] matrices = new Matrix4[Meshes.Count];
            for (int i = 0; i &lt; Meshes.Count; i++)
            {
                matrices[i] = Meshes[i].Transform.GetModelMatrix();
            }
            // for GOD KNOWS WHY
            // matrix turns when i put them in the vertex shader, so i will turn them here (or chatgpt will ig idk m*th)
            Matrix4[] rotatedMatrixes = new Matrix4[matrices.Length];
            for (int i = 0; i &lt; matrices.Length; i++)
            {
                Matrix4 matrix = matrices[i];
              
                rotatedMatrixes[i] = matrix.RotateMatrixForInstancedRendering();
            }
            SetMatrix4(rotatedMatrixes, 12, 1);
        }

        public void PrepareRender(Light light)
        {
            if (Meshes.Count == 0) return;

            var shader = Meshes[0].Shader;
            shader.Use();

            if (Meshes[0] is LightEffectedMesh lightMesh)
                lightMesh.SetStaticUniforms(light); // handles light uniforms

            GL.Enable(EnableCap.CullFace); // optional: control based on mesh settings
        }
        public void EndRender() =&gt; GL.Disable(EnableCap.CullFace);

        #region render
        public void Render(PrimitiveType type = PrimitiveType.Triangles)
        {
            T ourMesh = Meshes[0];
            ourMesh.Shader.SetMatrix4("projection", ourMesh.Camera.GetProjectionMatrix());
            ourMesh.Shader.SetMatrix4("view", ourMesh.Camera.GetViewMatrix());

            GL.BindVertexArray(ourMesh.VertexArrayObjectPointer);
            GL.DrawArraysInstanced(type, 0, ourMesh.size, Meshes.Count);
        }
        public void RenderWithIndices(PrimitiveType type = PrimitiveType.Triangles)
        {
            T ourMesh = Meshes[0];

            ourMesh.Shader.SetMatrix4("projection", ourMesh.Camera.GetProjectionMatrix());
            ourMesh.Shader.SetMatrix4("view", ourMesh.Camera.GetViewMatrix());

            GL.BindVertexArray(ourMesh.VertexArrayObjectPointer);
            GL.DrawElementsInstanced(type, ourMesh.indices.Length, DrawElementsType.UnsignedInt, 0, Meshes.Count); // render the mesh
        }
        #endregion
    }
}
]]></description><link>api\rendering\meshclasses\instancedmesh.cs.html</link><guid isPermaLink="false">API/Rendering/MeshClasses/InstancedMesh.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[InstancedMeshShaders.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Graphics.OpenGL;
using OpenTK.Mathematics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace OpenglTestConsole.Classes.API.Rendering.MeshClasses
{
    public partial class InstancedMesh&lt;T&gt; where T : Mesh
    {

        public void SetMatrix4(Matrix4[] matrices, int loc, int offset = 1)
        {
            int vbo = GL.GenBuffer();

            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferData(BufferTarget.ArrayBuffer, matrices.Length * Marshal.SizeOf&lt;Matrix4&gt;(), matrices, BufferUsageHint.StaticDraw);

            foreach (T mesh in Meshes)
            {
                GL.BindVertexArray(mesh.VertexArrayObjectPointer); // bind the vertex array so that the buffer we made is used on this

                int matrixSize = Marshal.SizeOf&lt;Matrix4&gt;();

                // Set up each column (vec4) of the mat4 as a separate attribute
                for (int i = 0; i &lt; 4; i++)
                {
                    int attribLocation = loc + i;
                    GL.EnableVertexAttribArray(attribLocation);
                    GL.VertexAttribPointer(attribLocation, 4, VertexAttribPointerType.Float, false, matrixSize, i * Vector4.SizeInBytes);
                    GL.VertexAttribDivisor(attribLocation, offset);
                }
            }
        }

        public void SetVector4(Vector4[] vectors, int loc, int offset = 1)
        {
            int VBOPointer = GL.GenBuffer();

            // generate vertex buffer object
            GL.BindBuffer(BufferTarget.ArrayBuffer, VBOPointer); // bind buffer
            GL.BufferData(BufferTarget.ArrayBuffer, vectors.Length * Vector4.SizeInBytes, vectors, BufferUsageHint.StaticDraw); // put data in buffer

            foreach (T mesh in Meshes)
            {
                GL.BindVertexArray(mesh.VertexArrayObjectPointer); // bind the vertex array so that the buffer we made is used on this

                GL.EnableVertexAttribArray(loc); // enable loc 0

                GL.VertexAttribPointer(loc, 4, VertexAttribPointerType.Float, false, Vector4.SizeInBytes, 0); // bind the buffer to location 0

                GL.VertexAttribDivisor(loc, offset);
            }
        }


        public Y[] GetFieldValuesFromMeshes&lt;Y&gt;(string fieldOrPropertyName)
        { // is this dumb? probably, but i dont care
            return Meshes.Select(mesh =&gt;
            {
                var type = mesh.GetType();

                // Try to get a field first
                var field = type.GetField(fieldOrPropertyName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                if (field != null &amp;&amp; field.FieldType == typeof(Y))
                    return (Y)field.GetValue(mesh)!;

                // Try to get a property if field not found
                var prop = type.GetProperty(fieldOrPropertyName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                if (prop != null &amp;&amp; prop.PropertyType == typeof(Y))
                    return (Y)prop.GetValue(mesh)!;

                throw new Exception($"Field or property '{fieldOrPropertyName}' not found or not of type {typeof(Y).Name} in mesh.");
            }).ToArray()!;
        }

    }
}
]]></description><link>api\rendering\meshclasses\instancedmeshshaders.cs.html</link><guid isPermaLink="false">API/Rendering/MeshClasses/InstancedMeshShaders.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Mesh.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Geometries;
using OpenglTestConsole.Classes.API.Rendering.Shaders;

namespace OpenglTestConsole.Classes.API.Rendering.MeshClasses
{
    public partial class Mesh
    {
        #region Init
        private Camera Camera
        {
            get =&gt; Scene.Camera;
        }

        private Geometry3D _geometry;
        public Geometry3D Geometry { get =&gt; _geometry; set { _geometry = value; _geometry.Apply(this.BufferManager); } }
        public Material Material { get; set; }
        public Transform Transform { get; set; } = new Transform();
        public BufferManager BufferManager { get; }

        // caps to enable before rendering
        public List&lt;EnableCap&gt; CapsToEnable { get; set; } = new();

        // caps to disable before rendering
        public List&lt;EnableCap&gt; CapsToDisable { get; set; } = new();

        // render type
        public PrimitiveType type { get; set; } = PrimitiveType.Triangles;

        public int VertexArrayObjectPointer { get; private set; }

        public Mesh(Geometry3D geometry, Material material)
        {
            this._geometry = geometry;
            this.Material = material;

            VertexArrayObjectPointer = GL.GenVertexArray();
            BufferManager = new BufferManager(VertexArrayObjectPointer);
            this.Geometry.Apply(this.BufferManager);
        }

        #endregion


        #region Render

        public virtual void Render()
        { // deadass render that shit cuh
            // on it boss ima render that shit cuh

            Enalbes();


            Material.Shader.Use();

            Material.Apply();

            Material.Shader.UniformManager.SetMatrix4("projection", Camera.GetProjectionMatrix());

            Material.Shader.UniformManager.SetMatrix4("view", Camera.GetViewMatrix());

            Material.Shader.UniformManager.SetMatrix4("model", Transform.GetModelMatrix());


            GL.BindVertexArray(VertexArrayObjectPointer);
            if (Geometry.IndicesLength &lt; 3) // check if we are using indices
                GL.DrawArrays(type, 0, Geometry.VerticesLength);
            GL.DrawElements(type, Geometry.IndicesLength, DrawElementsType.UnsignedInt, 0);

            Disables();
        }

        private void Enalbes()
        {
            foreach (EnableCap cap in CapsToDisable)
                GL.Disable(cap);

            foreach (EnableCap cap in CapsToEnable)
                GL.Enable(cap);
        }

        private void Disables()
        {
            foreach (EnableCap cap in CapsToDisable)
                GL.Enable(cap);

            foreach (EnableCap cap in CapsToEnable)
                GL.Disable(cap);
        }

        #endregion
    }
}
]]></description><link>api\rendering\meshclasses\mesh.cs.html</link><guid isPermaLink="false">API/Rendering/MeshClasses/Mesh.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[ComputeShader.cs]]></title><description><![CDATA[ 
 <br>using System.Numerics;
using OpenglTestConsole.Classes.API.Misc;

namespace OpenglTestConsole.Classes.API.Rendering.Shaders.Compute
{
    public class ComputeShader : IDisposable
    { // https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction
        public bool initalised = false;
        public string computeShaderPath;
        public int Handle;
        public ComputeShaderUnitManager UnitManager;
        public ShaderUniformManager UniformManager;
        private bool disposed = false;
        public Vector3 groupSize { get; private set; }

        public ComputeShader(string computeShaderPath)
        {
            this.computeShaderPath = computeShaderPath;
            UnitManager = new ComputeShaderUnitManager(Handle);
            UniformManager = new ShaderUniformManager(Handle);
        }

        public void Init()
        {
            Handle = GL.CreateProgram();

            int computeShaderPointer = HandleComputeShader(computeShaderPath);

            GL.AttachShader(Handle, computeShaderPointer);

            GL.LinkProgram(Handle);

            GL.GetProgram(Handle, GetProgramParameterName.LinkStatus, out int shaderLinkSuccess);

            if (shaderLinkSuccess == 0)
            {
                string errorLog = GL.GetProgramInfoLog(Handle);
                Logger.Log(
                    $"An error occured while loading compute shader for {LogColors.BrightWhite(Handle)}!\nError log:\n{errorLog}",
                    LogLevel.Error
                );
            }

            // get the group size
            int[] size = new int[3];
            GL.GetProgram(Handle, (GetProgramParameterName)All.ComputeWorkGroupSize, size);
            groupSize = new Vector3(size[0], size[1], size[2]);

            GL.DetachShader(Handle, computeShaderPointer);
            GL.DeleteShader(computeShaderPointer);

            initalised = true;
        }

        public int HandleComputeShader(string path)
        {
            string computeSource;

            try
            {
                computeSource = File.ReadAllText(path);
            }
            catch (Exception e)
            {
                Logger.Log(
                    $"An error occured while reading compute shader {LogColors.BrightWhite(path)}!\nError log:\n{e}",
                    LogLevel.Error
                );
                return -1;
            }

            int computeShaderPointer = GL.CreateShader(ShaderType.ComputeShader);

            GL.ShaderSource(computeShaderPointer, computeSource);

            GL.CompileShader(computeShaderPointer);

            GL.GetShader(
                computeShaderPointer,
                ShaderParameter.CompileStatus,
                out int shaderCompileSuccess
            );

            if (shaderCompileSuccess == 0)
            {
                string errorLog = GL.GetShaderInfoLog(computeShaderPointer);
                Logger.Log(
                    $"An error occured while loading compute shader {LogColors.BrightWhite(path)}!\nError log:\n{errorLog}",
                    LogLevel.Error
                );
            }

            return computeShaderPointer;
        }

        public void DispatchForSize(int x, int y, int z)
        {
            Dispatch((int)(x / groupSize.X), (int)(y / groupSize.Y), (int)(z / groupSize.Z));
        }

        public void Dispatch(int x, int y, int z)
        {
            Use();
            if (initalised == false)
            {
                Logger.Log(
                    $"Shader with {LogColors.BrightWhite(Handle)} used without initalisation, initalising..",
                    LogLevel.Warning
                );
                Init();
            }
            GL.DispatchCompute(x, y, z);
        }

        #region unimportants
        ~ComputeShader()
        {
            if (disposed == false)
                Logger.Log($"GPU Resource leak! Did you forget to call Dispose()?", LogLevel.Error);
        }

        public void Use()
        {
            if (initalised == false)
            {
                Logger.Log(
                    $"Shader with {LogColors.BrightWhite(Handle)} used without initalisation, initalising..",
                    LogLevel.Warning
                );
                Init();
            }
            GL.UseProgram(Handle);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                GL.DeleteProgram(Handle);
                Logger.Log(
                    $"{LogColors.BrightYellow("Disposed")} compute shader {LogColors.BrightWhite(Handle)}",
                    LogLevel.Detail
                );
                disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
]]></description><link>api\rendering\shaders\compute\computeshader.cs.html</link><guid isPermaLink="false">API/Rendering/Shaders/Compute/ComputeShader.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[ComputeShaderUnitManager.cs]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Rendering.Shaders.Compute
{
    public class ComputeShaderUnitManager
    {
        public struct ImageBinding
        {
            public int Unit;
            public int Texture;
            public TextureAccess Access;
            public SizedInternalFormat Format;

            public ImageBinding(
                int unit,
                int texture,
                TextureAccess access,
                SizedInternalFormat format
            )
            {
                Unit = unit;
                Texture = texture;
                Access = access;
                Format = format;
            }
        }

        private int Handle;
        private List&lt;ImageBinding&gt; imageBindings = new List&lt;ImageBinding&gt;();

        public ComputeShaderUnitManager(int handle)
        {
            Handle = handle;
        }

        public void SetImageTexture(
            int texture,
            int unit,
            TextureAccess access = TextureAccess.ReadWrite,
            SizedInternalFormat format = SizedInternalFormat.Rgba32f
        )
        {
            // Remove any existing binding on that unit to avoid duplicates
            imageBindings.RemoveAll(b =&gt; b.Unit == unit);

            imageBindings.Add(new ImageBinding(unit, texture, access, format));
        }

        public void ApplyTextures()
        {
            foreach (var binding in imageBindings)
            {
                GL.BindImageTexture(
                    binding.Unit, // Image unit index, corresponds to 'binding = unit' in GLSL
                    binding.Texture, // OpenGL texture handle
                    0, // Mipmap level
                    false, // Not layered
                    0, // Layer index
                    binding.Access, // WriteOnly, ReadOnly, or ReadWrite
                    binding.Format // Must match texture's internal format
                );
            }
        }
    }
}
]]></description><link>api\rendering\shaders\compute\computeshaderunitmanager.cs.html</link><guid isPermaLink="false">API/Rendering/Shaders/Compute/ComputeShaderUnitManager.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Shader.cs]]></title><description><![CDATA[ 
 <br>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OpenglTestConsole.Classes.API.Rendering.Shaders
{
    public partial class Shader
    {
        public string geometryPath { get; set; } = "NULL";
        public Shader(string vertexPath, string fragmentPath, string geometryPath)
        { this.vertexPath = vertexPath; this.fragmentPath = fragmentPath; this.geometryPath = geometryPath; }
        private void InitGeometry()
        {
            if (this.geometryPath == "NULL")
                return;

            int geomShaderPointer = HandleShader(geometryPath, ShaderType.GeometryShader);

            GL.AttachShader(Handle, geomShaderPointer);
        }
    }
}
]]></description><link>api\rendering\shaders\geometry\shader.cs.html</link><guid isPermaLink="false">API/Rendering/Shaders/Geometry/Shader.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Material.cs]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Rendering.Shaders
{
    public abstract class Material
    {
        // ok the plan should be easy
        // so i have Mesh but i want to set each mesh to a specific material
        // i can do it in the constructor, but thats meh
        // so ill just use generalised types like Mesh&lt;T&gt; extends material or w/e
        public Material() { }

        public Shader Shader { get; set; }

        public abstract void Apply();
    }
}
]]></description><link>api\rendering\shaders\material.cs.html</link><guid isPermaLink="false">API/Rendering/Shaders/Material.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Shader.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;

namespace OpenglTestConsole.Classes.API.Rendering.Shaders
{
    public partial class Shader : IDisposable
    {
        #region Main Shader Functions
        public bool initalised = false;
        public string vertexPath;
        public string fragmentPath;
        public int Handle { get; set; }
        private bool disposed = false;
        public ShaderUniformManager UniformManager;

        public Shader(string vertexPath, string fragmentPath)
        { this.vertexPath = vertexPath; this.fragmentPath = fragmentPath; }

        public void Init()
        {
            Handle = GL.CreateProgram();

            this.UniformManager = new ShaderUniformManager(Handle);

            int vertShaderPointer = HandleShader(vertexPath, ShaderType.VertexShader);

            int fragShaderPointer = HandleShader(fragmentPath, ShaderType.FragmentShader);

            GL.AttachShader(Handle, vertShaderPointer);
            GL.AttachShader(Handle, fragShaderPointer);

            // init the geometry shader, if we have one
            InitGeometry();

            GL.LinkProgram(Handle);

            GL.GetProgram(Handle, GetProgramParameterName.LinkStatus, out int shaderLinkSuccess);

            if (shaderLinkSuccess == 0)
            {
                string errorLog = GL.GetProgramInfoLog(Handle);
                Logger.Log(
                    $"An error occured while loading shaders for {LogColors.BrightWhite(Handle)}!\nError log:\n{errorLog}",
                    LogLevel.Error
                );
            }

            GL.DetachShader(Handle, vertShaderPointer);
            GL.DetachShader(Handle, fragShaderPointer);
            GL.DeleteShader(vertShaderPointer);
            GL.DeleteShader(fragShaderPointer);

            initalised = true;
        }

        private int HandleShader(string path, ShaderType type)
        {
            string source;

            try
            {
                source = File.ReadAllText(path);
            }
            catch (Exception ex)
            {
                Logger.Log(
                    $"An error occured while loading {LogColors.BrightWhite(path)} for {LogColors.BrightWhite(Handle)} for {LogColors.BrightWhite(type.ToString())}:\n{ex.ToString()}",
                    LogLevel.Error
                );
                Logger.Log($"Exiting", LogLevel.Error);
                throw;
            }

            int shaderPointer = GL.CreateShader(type);

            GL.ShaderSource(shaderPointer, source);

            GL.CompileShader(shaderPointer);

            GL.GetShader(
                shaderPointer,
                ShaderParameter.CompileStatus,
                out int shaderSuccess
            );

            if (shaderSuccess == 0)
            {
                string errorLog = GL.GetShaderInfoLog(shaderPointer);
                Logger.Log(
                    $"An error occured while loading shaders for {LogColors.BrightWhite(Handle)}!\nError log:\n{errorLog}",
                    LogLevel.Error
                );
            }

            Logger.Log(
                $"Loaded {LogColors.White(type)} for {LogColors.BrightWhite(Handle)} : {LogColors.BrightWhite(path)}",
                LogLevel.Detail
            );

            return shaderPointer;
        }

        ~Shader()
        {
            if (disposed == false)
            {
                Logger.Log(
                    $"GPU Resource leak for shader! Did you forget to call Dispose()?",
                    LogLevel.Error
                );
            }
        }

        public void Use()
        {
            if (initalised == false)
            {
                Logger.Log(
                    $"Shader with {LogColors.BrightWhite(Handle)} used without initalisation, initalising..",
                    LogLevel.Warning
                );
                Init();
            }
            GL.UseProgram(Handle);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                GL.DeleteProgram(Handle);
                Logger.Log(
                    $"{LogColors.BrightYellow("Disposed")} shader {LogColors.BrightWhite(Handle)}",
                    LogLevel.Detail
                );
                disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}
]]></description><link>api\rendering\shaders\shader.cs.html</link><guid isPermaLink="false">API/Rendering/Shaders/Shader.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[ShaderUniformManager.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Textures;
using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering.Shaders
{
    public class ShaderUniformManager
    {
        private int Handle;

        public ShaderUniformManager(int handle)
        {
            Handle = handle;
        }

        #region Uniform Functions
        // cache uniforms so we dont run *expensive* get uniform location a shit ton
        private Dictionary&lt;string, int&gt; uniformCache = new Dictionary&lt;string, int&gt;();

        public void SetMatrix4(string name, Matrix4 matrix)
        {
            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                GL.UniformMatrix4(loc, true, ref matrix);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetMatrix4(name, matrix);
            }
        }

        public void SetVector4(string name, Vector4 vector)
        {
            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                GL.Uniform4(loc, vector);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetVector4(name, vector);
            }
        }

        public void SetVector3(string name, Vector3 vector)
        {
            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                GL.Uniform3(loc, vector);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetVector3(name, vector);
            }
        }

        public void SetVector2(string name, Vector2 vector)
        {
            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                GL.Uniform2(loc, vector);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetVector2(name, vector);
            }
        }

        public void SetFloat(string name, float value)
        {
            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                GL.Uniform1(loc, value);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetFloat(name, value);
            }
        }

        public void SetInt(string name, int value)
        {
            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                GL.Uniform1(loc, value);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetInt(name, value);
            }
        }

        public void SetColor(string name, Color4 color)
        {
            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                GL.Uniform4(loc, color);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetColor(name, color);
            }
        }

        public void SetTexture(string name, Texture tex, OpenTK.Graphics.OpenGL.TextureUnit unit)
        {
            tex.Activate(unit);
            tex.Bind();

            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                int unitint = (int)unit - (int)TextureUnit.Texture0;
                GL.Uniform1(loc, unitint);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetTexture(name, tex, unit);
            }
        }

        public void SetCubemap(string name, Cubemap cubemap, OpenTK.Graphics.OpenGL.TextureUnit unit)
        {

            cubemap.Activate(unit);
            cubemap.Bind();

            if (uniformCache.ContainsKey(name))
            {
                uniformCache.TryGetValue(name, out int loc);
                int unitint = (int)unit - (int)TextureUnit.Texture0;
                GL.Uniform1(loc, unitint);
            }
            else
            {
                uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
                SetCubemap(name, cubemap, unit);
            }
        }

        #endregion
    }
}
]]></description><link>api\rendering\shaders\shaderuniformmanager.cs.html</link><guid isPermaLink="false">API/Rendering/Shaders/ShaderUniformManager.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Cubemap.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.AccessControl;
using System.Text;
using System.Threading.Tasks;

namespace OpenglTestConsole.Classes.API.Rendering.Textures
{
    public class Cubemap : IDisposable
    {
        public int Handle { get; set; }
        public bool initalised = false;
        private bool _disposed = false;
        public bool disposed
        {
            get
            { // İF all of the textures are disposed *and* this cubemap is disposed, then return disposed
                return textures.All(tex =&gt; tex.disposed) &amp;&amp; this._disposed == true;
            }
            private set =&gt; _disposed = value;
        }

        #region sides
        public Texture Right { get; init; }
        public Texture Left { get; init; }
        public Texture Top { get; init; }
        public Texture Bottom { get; init; }
        public Texture Back { get; init; }
        public Texture Front { get; init; }
        public Texture[] textures { get =&gt; [Right, Left, Top, Bottom, Front, Back]; }
        #endregion

        public Cubemap(Texture[] inTextures)
        {
            #pragma warning disable format
            Right   =   inTextures[0];      Left    =     inTextures[1];
            Top     =   inTextures[2];      Bottom  =     inTextures[3];
            Back    =   inTextures[4];      Front   =     inTextures[5];      
            #pragma warning restore format
        }

        public void Init()
        {
            Handle = GL.GenTexture();
            GL.BindTexture(TextureTarget.Texture2D, Handle);


            if (this.textures.Any(tex =&gt; tex.initalised == true))
            { // check if any of the textures are initalized, we need them to not be initalized
                string initalisedTextures = "";
                foreach (Texture tex in textures)
                {
                    if (tex.initalised)
                    {
                        initalisedTextures += $"{LogColors.BrightWhite(tex.Handle)}, ";
                    }
                }

                Logger.Log($"Cubemap {LogColors.BrightWhite(Handle)} recieved initalised Texture(s): {initalisedTextures}", LogLevel.Error);
            }

            for (int i = 0; i &lt; textures.Length; i++)
            {
                Texture tex = textures[i]; // set the cube map type of the texture
                tex.Target = TextureTarget.TextureCubeMapPositiveX + i;
                tex.flipped = false;
                tex.Init(); // init it while we are binded to the cubemap, which will attatch the texture to the cubemap
            }

            /* 
                https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/6.2.cubemaps_environment_mapping/cubemaps_environment_mapping.cpp
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); // x clamping
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // y clamping
                glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); // z clamping
             */

            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);

            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
            GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
            Logger.Log(
                $"Initalized Cubemap {LogColors.BrightWhite(Handle)}",
                LogLevel.Detail
            );

            this.initalised = true;
        }

        private void Check()
        {
            if (initalised)
                return;
            Logger.Log($"Cubemap {Handle} used without initalisation", LogLevel.Error);
        }
        public void Bind()
        {
            Check();
            GL.BindTexture(TextureTarget.Texture2D, Handle);
        }
        public void Activate(TextureUnit unit)
        {
            Check();
            GL.ActiveTexture(unit);
        }

        #region disposal
        ~Cubemap()
        {
            if (disposed == false)
                Logger.Log(
                    $"GPU Resource leak for cubemap! Did you forget to call Dispose()?",
                    LogLevel.Error
                );
        }

        protected virtual void Dispose(bool disposing, bool log = true)
        {
            if (!disposed)
            {
                if (log)
                    Logger.Log(
                    $"{LogColors.BrightYellow("Disposed")} Cubemap {LogColors.BrightWhite(Handle)}",
                    LogLevel.Detail
                );
                foreach (var texture in textures)
                    texture.Dispose();
                GL.DeleteTexture(Handle);
                Handle = 0;
                disposed = true;
            }
        }
        public bool logDisposal = true;

        public void Dispose()
        {
            Dispose(true, logDisposal);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
]]></description><link>api\rendering\textures\cubemap.cs.html</link><guid isPermaLink="false">API/Rendering/Textures/Cubemap.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[FBO.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.Implementations.Classes;

namespace OpenglTestConsole.Classes.API.Rendering.Textures
{
    public class FBO
    {
        public int Handle { get; set; }
        public FBO()
        {

        }
        public void Init()
        {
            // you just HAD to do shit with pointers
            unsafe
            {
                uint temp = 0; // create the fbo
                GL.CreateFramebuffers(1, &amp;temp);
                Handle = (int)temp;
            }

            // bind the fbo so we are working on it
            GL.BindFramebuffer(FramebufferTarget.Framebuffer, Handle);
            int x = Settings.Resolution.X;
            int y = Settings.Resolution.Y;

            // create texture thats the same size as the window (not required)
            // TODO: change this when we get settings for window size or w/e
            Texture colorTexture = Texture.LoadFromSize(x, y);

            GL.FramebufferTexture2D( // attatch the texture
                FramebufferTarget.Framebuffer, // the frame buffer will write to this texture
                FramebufferAttachment.ColorAttachment0, // attatchment type
                TextureTarget.ProxyTexture2D, // texture type
                colorTexture.Handle,
                0 // mipmap level
             );

            // create the depth and stencil texture
            Texture depthAndStencilTexture = Texture.LoadFromSize(
                x,
                y,
                target: TextureTarget.Texture2D,
                pixelInternalFormat: PixelInternalFormat.Depth24Stencil8,
                pixelFormat: PixelFormat.DepthStencil,
                type: PixelType.UnsignedInt248
             );

            // bind the depth and stencil texture
            GL.FramebufferTexture2D( // same as the above texture 2d
                FramebufferTarget.Framebuffer,
                FramebufferAttachment.DepthStencilAttachment,
                TextureTarget.Texture2D,
                depthAndStencilTexture.Handle,
                0
             );

            if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)
            {
                Misc.Logger.Log(
                   $"An error occured while creating frame buffer for {Misc.LogColors.BrightWhite(Handle)} :\n" +
                   $"{GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer).ToString()}",
                   Misc.LogLevel.Error
                );
            }
            else
            {
                Misc.Logger.Log(
                    $"Loaded FBO {Misc.LogColors.BrightWhite(Handle)}:\n" +
                    $"Color Texture: {Misc.LogColors.BrightWhite(colorTexture.Handle)}" +
                    $"Depth &amp; Stencil: {Misc.LogColors.BrightWhite(depthAndStencilTexture.Handle)}",
                   Misc.LogLevel.Detail
                );
            }
            // execute victory dance
        }


    }
}
]]></description><link>api\rendering\textures\fbo.cs.html</link><guid isPermaLink="false">API/Rendering/Textures/FBO.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Texture.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;
using OpenTK.Audio.OpenAL;
using OpenTK.Mathematics;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using System.IO;
using static OpenglTestConsole.Generated.Paths.ResourcePaths.Materials;

namespace OpenglTestConsole.Classes.API.Rendering.Textures
{
    public class Texture : IDisposable
    {
        public int Handle { get; set; }
        public bool initalised = false;
        public int width, height;
        public bool disposed { get; private set; } = false;

        #region creation
        public TextureTarget Target { get; set; }
        public PixelInternalFormat PixelInternalFormat { get; set; }
        public PixelFormat PixelFormat { get; set; }
        public PixelType PixelType { get; set; }
        public TextureWrapMode TextureSWrapMode { get; set; }
        public TextureWrapMode TextureTWrapMode { get; set; }
        private byte[] bytes { get; set; }
        public bool flipped = true;
        public Texture() { }

        public static Texture LoadFromFile(
            string path,
            TextureTarget target = TextureTarget.Texture2D,
            PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba,
            PixelFormat pixelFormat = PixelFormat.Rgba,
            PixelType type = PixelType.UnsignedByte,
            TextureWrapMode textureSWrapMode = TextureWrapMode.Repeat,
            TextureWrapMode textureTWrapMode = TextureWrapMode.Repeat
        ) =&gt; LoadFromTextureBytes(
                 File.ReadAllBytes(path),
                 target: target,
                 pixelInternalFormat: pixelInternalFormat,
                 pixelFormat: pixelFormat,
                 type: type,
                 textureSWrapMode: textureSWrapMode,
                 textureTWrapMode: textureTWrapMode
            );


        public static Texture LoadFromTextureBytes(
            byte[] bytes,
            TextureTarget target = TextureTarget.Texture2D,
            PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba,
            PixelFormat pixelFormat = PixelFormat.Rgba,
            PixelType type = PixelType.UnsignedByte,
            TextureWrapMode textureSWrapMode = TextureWrapMode.Repeat,
            TextureWrapMode textureTWrapMode = TextureWrapMode.Repeat
        )
        {

            Image&lt;Rgba32&gt; image;

            try
            {
                image = Image.Load&lt;Rgba32&gt;(bytes);
            }
            catch (Exception ex)
            {
                Logger.Log(
                    $"An error occured while loading {LogColors.BrightWhite("LoadFromTextureBytes")}:\n{ex.ToString()}",
                    LogLevel.Error
                );
                // this aint working properly fix it sometime ig
                Logger.Log($"Using default texture...", LogLevel.Warning);
                image = Image.Load&lt;Rgba32&gt;(File.ReadAllBytes("Resources/Textures/PlaceHolder.png"));
            }


            byte[] pixelDataArray = new byte[image.Width * image.Height * 4];
            image.CopyPixelDataTo(pixelDataArray);

            Texture texture = LoadFromBytes(
                bytes: pixelDataArray,
                width: image.Width,
                height: image.Height,
                target: target,
                pixelInternalFormat: pixelInternalFormat,
                pixelFormat: pixelFormat,
                type: type,
                textureSWrapMode: textureSWrapMode,
                textureTWrapMode: textureTWrapMode
            );
            image.Dispose();

            return texture;
        }

        public static Texture LoadFromBytes(
            byte[] bytes,
            int width,
            int height,
            TextureTarget target = TextureTarget.Texture2D,
            PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba,
            PixelFormat pixelFormat = PixelFormat.Rgba,
            PixelType type = PixelType.UnsignedByte,
            TextureWrapMode textureSWrapMode = TextureWrapMode.Repeat,
            TextureWrapMode textureTWrapMode = TextureWrapMode.Repeat
        )
        {
            Texture texture = new();
            texture.bytes = bytes;
            texture.width = width;
            texture.height = height;
            texture.Target = target;
            texture.PixelInternalFormat = pixelInternalFormat;
            texture.PixelFormat = pixelFormat;
            texture.PixelType = type;
            texture.TextureSWrapMode = textureSWrapMode;
            texture.TextureTWrapMode = textureTWrapMode;

            return texture;
        }

        public void Init()
        {
            this.Handle = GL.GenTexture();

            if (flipped)
            {
                var image = Image.LoadPixelData&lt;Rgba32&gt;(
                    data: bytes,
                    width: width,
                    height: height
                );
                image.Mutate(s =&gt; s.Flip(FlipMode.Vertical));
                image.CopyPixelDataTo(bytes);
                image.Dispose();
            }

            if (this.Handle == 0)
                Logger.Log(
                    $"Failed to generate texture for LoadFromBytes",
                LogLevel.Error
                );

            GL.BindTexture(TextureTarget.Texture2D, this.Handle);

            GL.TexParameter(
                TextureTarget.Texture2D,
                TextureParameterName.TextureWrapS,
                (int)TextureSWrapMode
            );
            GL.TexParameter(
                TextureTarget.Texture2D,
                TextureParameterName.TextureWrapT,
                (int)TextureTWrapMode
            );

            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureBaseLevel, 0);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMaxLevel, 0);
            GL.TexImage2D(
                this.Target,
                0,
                this.PixelInternalFormat,
                width,
                height,
                0,
                this.PixelFormat,
                this.PixelType,
                bytes
            );
            this.initalised = true;
            this.bytes = [];
            Logger.Log(
                $"Initalized texture {LogColors.BrightWhite(this.Handle)}",
                LogLevel.Detail
            );
        }

        public static Texture LoadFromSize( // shouldnt need an init
            int width,
            int height,
            TextureTarget target = TextureTarget.Texture2D,
            PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba,
            PixelFormat pixelFormat = PixelFormat.Rgba,
            PixelType type = PixelType.UnsignedByte
        )
        {
            Texture texture = new Texture();
            texture.Handle = GL.GenTexture();
            texture.width = width;
            texture.height = height;
            GL.BindTexture(TextureTarget.Texture2D, texture.Handle);
            GL.TexParameter(
                TextureTarget.Texture2D,
                TextureParameterName.TextureWrapS,
                (int)TextureWrapMode.Repeat
            );
            GL.TexParameter(
                TextureTarget.Texture2D,
                TextureParameterName.TextureWrapT,
                (int)TextureWrapMode.Repeat
            );
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureBaseLevel, 0);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMaxLevel, 0);
            GL.TexImage2D(
                target,
                0,
                pixelInternalFormat,
                width,
                height,
                0,
                pixelFormat,
                type,
                nint.Zero
            );
            texture.initalised = true;
            Logger.Log(
                $"Initalized empty texture {LogColors.BrightWhite(texture.Handle)}: {LogColors.BrightWhite(width)}x{LogColors.BrightWhite(height)}",
                LogLevel.Detail
            );
            return texture;
        }
        #endregion

        #region opengl functions
        private void Check()
        {
            if (initalised)
                return;
            Logger.Log($"Texture {Handle} used without initalisation", LogLevel.Error);
        }

        public void Bind()
        {
            Check();
            GL.BindTexture(TextureTarget.Texture2D, Handle);
        }

        public void Activate(TextureUnit unit)
        {
            Check();
            GL.ActiveTexture(unit);
        }
        #endregion

        public byte[] GetBytes()
        {
            byte[] output = new byte[
                4 *
                width *
                height
            ];

            unsafe
            {
                fixed (byte* outputPtr = output)
                {
                    Bind();
                    GL.GetTexImage(
                        TextureTarget.Texture2D,
                        0,
                        PixelFormat.Rgba,
                        PixelType.UnsignedByte,
                        (nint)outputPtr
                    );
                }
            }

            return output;
        }

        public void SaveToFile(string filePath)
        {
            Vector2i size = new(width, height);
            var image = Image.LoadPixelData&lt;Rgba32&gt;(GetBytes(), size.X, size.Y);
            image.Mutate(s =&gt; s.Flip(FlipMode.Vertical));
            if (filePath.Contains(".jpg") || filePath.Contains(".jpeg"))
                image.SaveAsJpeg(filePath);
            else
                image.SaveAsPng(filePath);
            Logger.Log(
                $"Saved Texture with {LogColors.BrightWhite(Handle)} as {LogColors.BrightWhite(filePath)}",
                LogLevel.Detail
            );
        }

        #region disposal
        ~Texture()
        {
            if (disposed == false)
                Logger.Log(
                    $"GPU Resource leak for texture! Did you forget to call Dispose()?",
                    LogLevel.Error
                );
        }

        protected virtual void Dispose(bool disposing, bool log = true)
        {
            if (!disposed)
            {
                if (log)
                    Logger.Log(
                    $"{LogColors.BrightYellow("Disposed")} Texture {LogColors.BrightWhite(Handle)}",
                    LogLevel.Detail
                );

                GL.DeleteTexture(Handle);
                Handle = 0;
                disposed = true;
            }
        }
        public bool logDisposal = true;

        public void Dispose()
        {
            Dispose(true, logDisposal);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
]]></description><link>api\rendering\textures\texture.cs.html</link><guid isPermaLink="false">API/Rendering/Textures/Texture.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Camera.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.Implementations.Classes;
using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering
{
    public class Camera
    {
        public Vector3 Position = Vector3.Zero;
        public int screenWidth;
        public int screenHeight;
        public float depthNear = 0.1f;
        public float depthFar = 400f;
        private float _pitch;
        private float _yaw = -MathHelper.PiOver2;
        private Vector3 _front = -Vector3.UnitZ;
        private Vector3 _up = Vector3.UnitY;
        private Vector3 _right = Vector3.UnitX;

        public float Pitch
        {
            get =&gt; MathHelper.RadiansToDegrees(_pitch);
            set
            {
                // We clamp the pitch value between -89 and 89 to prevent the camera from going upside down, and a bunch
                // of weird "bugs" when you are using euler angles for rotation.
                // If you want to read more about this you can try researching a topic called gimbal lock
                var angle = MathHelper.Clamp(value, -89f, 89f);
                _pitch = MathHelper.DegreesToRadians(angle);
                UpdateVectors();
            }
        }
        public float Yaw
        {
            get =&gt; MathHelper.RadiansToDegrees(_yaw);
            set
            {
                _yaw = MathHelper.DegreesToRadians(value);
                UpdateVectors();
            }
        }

        public Camera(int screenWidth, int screenHeight)
        {
            this.screenWidth = screenWidth;
            this.screenHeight = screenHeight;
        }

        public Matrix4 GetViewMatrix()
        {
            return Matrix4.LookAt(Position, Position + _front, _up);
        }

        public Matrix4 GetProjectionMatrix()
        {
            return Matrix4.CreatePerspectiveFieldOfView(
                Settings.FOVRadian,
                screenWidth / screenHeight,
                //1.333f, // 1.333 looks less trippy so
                //1f,
                depthNear,
                depthFar
            );
        }

        // This function is going to update the direction vertices using some of the math learned in the web tutorials.
        private void UpdateVectors()
        {
            // First, the front matrix is calculated using some basic trigonometry.
            _front.X = MathF.Cos(_pitch) * MathF.Cos(_yaw);
            _front.Y = MathF.Sin(_pitch);
            _front.Z = MathF.Cos(_pitch) * MathF.Sin(_yaw);

            // We need to make sure the vectors are all normalized, as otherwise we would get some funky results.
            _front = Vector3.Normalize(_front);

            // Calculate both the right and the up vector using cross product.
            // Note that we are calculating the right from the global up; this behaviour might
            // not be what you need for all cameras so keep this in mind if you do not want a FPS camera.
            _right = Vector3.Normalize(Vector3.Cross(_front, Vector3.UnitY));
            _up = Vector3.Normalize(Vector3.Cross(_right, _front));
        }
    }
}
]]></description><link>api\rendering\camera.cs.html</link><guid isPermaLink="false">API/Rendering/Camera.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Light.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering
{
    public class Light
    {
        public Vector3 Position = Vector3.Zero;
        public Vector3 Color = Vector3.Zero;

        public Light(Vector3 location, Vector3 color)
        {
            Position = location;
            Color = color;
        }

        public Vector3 Specular
        {
            get =&gt; Color;
        }
        public Vector3 Diffuse
        {
            get =&gt; Color * 0.7f;
        }
        public Vector3 Ambient
        {
            get =&gt; Color * 0.4f;
        }
    }
}
]]></description><link>api\rendering\light.cs.html</link><guid isPermaLink="false">API/Rendering/Light.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[RenderScript.cs]]></title><description><![CDATA[ 
 <br>using System.Diagnostics;
using OpenTK.Windowing.Common;

namespace OpenglTestConsole.Classes.API.Rendering
{
    public abstract class RenderScript
    {
        public FrameEventArgs args;
        public Camera Camera { get; set; }
        public Stopwatch Timer { get; set; }
        public Scene Scene { get; set; }
        public abstract void Init();
        public abstract void Advance();

        public virtual void OnResourceRefresh() { }
        public virtual void BeforeRender() { }
        public virtual void AfterRender() { }
    }
}
]]></description><link>api\rendering\renderscript.cs.html</link><guid isPermaLink="false">API/Rendering/RenderScript.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Transform.cs]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;

namespace OpenglTestConsole.Classes.API.Rendering
{
    public class Transform
    {
        public Vector3 Position = Vector3.Zero;
        private Vector3 _rotation = Vector3.Zero;
        public Vector3 Rotation = Vector3.Zero;
        private Matrix4 cacheMatrix = Matrix4.Identity;

        public Transform()
        {
            UpdateMatrix();
        }

        public void UpdateMatrix()
        {
            _rotation = Rotation * new Vector3((float)(Math.PI / 180f));
            Matrix4 rotation =
                Matrix4.CreateRotationX(_rotation.Y)
                * Matrix4.CreateRotationY(_rotation.Z)
                * Matrix4.CreateRotationZ(_rotation.X);

            this.cacheMatrix =
                Matrix4.CreateScale(Scale)
                * rotation
                * Matrix4.CreateTranslation(Position)
                * Matrix4.Identity;
        }

        public Vector3 Scale = Vector3.One;

        public Matrix4 GetModelMatrix()
        {
            // DONE: you only need to reinitilise rotation when the rotation is updated, make this more efficent
            // you dont even need to remake the whole thing really, cache this thing cuh!

            return cacheMatrix;
        }

        public void Reset()
        {
            Position = Vector3.Zero;
            Rotation = Vector3.Zero;
            Scale = Vector3.One;
            UpdateMatrix();
        }
    }
}
]]></description><link>api\rendering\transform.cs.html</link><guid isPermaLink="false">API/Rendering/Transform.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[EveryFrameScript.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering;
using OpenTK.Windowing.Common;
using OpenTK.Windowing.GraphicsLibraryFramework;

namespace OpenglTestConsole.Classes.API
{
    public abstract class EveryFrameScript
    {
        public MouseState MouseState { get; set; }
        public KeyboardState KeyboardState { get; set; }
        public Camera Camera { get; set; }
        public Main MainInstance { get; set; }
        public FrameEventArgs args { get; set; }
        public abstract void Init();
        public abstract void Advance();

        public virtual void OnResourceRefresh() { }
    }
}
]]></description><link>api\everyframescript.cs.html</link><guid isPermaLink="false">API/EveryFrameScript.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[ResourceController.cs]]></title><description><![CDATA[ 
 <br>using System.Reflection;
using OpenglTestConsole.Classes.API.JSON;
using OpenglTestConsole.Classes.API.Misc;
using OpenglTestConsole.Classes.API.Rendering.Shaders;
using OpenglTestConsole.Classes.API.Rendering.Shaders.Compute;
using OpenglTestConsole.Classes.API.Rendering.Textures;
using OpenglTestConsole.Generated.Paths;

namespace OpenglTestConsole.Classes.API
{
    public class ResourceController
    {
        public static void Refresh()
        {
            foreach (KeyValuePair&lt;string, Shader&gt; item in Resources.Shaders)
                item.Value.Dispose();

            foreach (KeyValuePair&lt;string, ComputeShader&gt; item in Resources.CompShaders)
                item.Value.Dispose();

            foreach (KeyValuePair&lt;string, Texture&gt; item in Resources.Textures)
                item.Value.Dispose();

            Resources.Shaders.Clear();
            Resources.Textures.Clear();
            Resources.CompShaders.Clear();
            Resources.Fonts.Clear();

            Init();
        }

        public static void Init()
        {
            AddTextures();
            AddShaders();
            // interesting intellisense suggestion aint it!
            // however materials are pmuch shaders, so
            // can do some texture pbr stuff ig
            // AddMaterials();
            AddComputeShaders();
            AddFonts();
            AddCubemaps();
        }
        #region textures
        private static void AddTextures()
        {
            foreach (FieldInfo texture in typeof(ResourcePaths.Resources.Textures).GetFields())
                AddTexture(texture);
        }

        private static void AddTexture(FieldInfo texture)
        {
            // get the constant path value from the class
            string texturePath = (string)texture.GetValue(null)!;
            // add the texture to the resources
            Resources.Textures.Add(texturePath, Texture.LoadFromFile(texturePath));
            Logger.Log($"Loading {LogColors.Green("Texture")} {LogColors.BrightWhite(texturePath)}", LogLevel.Detail);
            Resources.Textures[texturePath].Init();
        }
        #endregion
        #region compute shaders
        private static void AddComputeShaders()
        {
            foreach (Type compShader in typeof(ResourcePaths.ComputeShaders).GetNestedTypes())
            {
                AddComputeShader(compShader);
            }
        }

        private static void AddComputeShader(Type type)
        {
            string shaderName = (string)type!.GetField("Name")!.GetValue(null)!;
            string compute = (string)type!.GetField("Compute")!.GetValue(null)!;
            // add the shader to the resources
            Resources.CompShaders.Add(shaderName, new(compute));
            Resources.CompShaders[shaderName].Init();
        }
        #endregion
        #region shaders
        private static void AddShaders()
        {
            foreach (var shader in typeof(ResourcePaths.Materials).GetNestedTypes())
                AddShader(shader);
        }

        private static void AddShader(Type type)
        {
            // get the shader information
            string shaderName = (string)type!.GetField("Name")!.GetValue(null)!;
            string fragment = (string)type!.GetField("Fragment")!.GetValue(null)!;
            string vertex = (string)type!.GetField("Vertex")!.GetValue(null)!;

            string? geometry = (string?)type?.GetField("Geometry")?.GetValue(null);
            if (string.IsNullOrEmpty(geometry))
                Resources.Shaders.Add(shaderName, new(vertex, fragment));
            else
                Resources.Shaders.Add(shaderName, new(vertex, fragment, geometry));
            // add the shader to the resources
            Logger.Log($"Loading {LogColors.Green("Shader")} {LogColors.BrightWhite(shaderName)}", LogLevel.Detail);

            Resources.Shaders[shaderName].Init();
        }
        #endregion
        #region fonts
        private static void AddFonts()
        {
            foreach (var font in typeof(ResourcePaths.Fonts).GetNestedTypes())
            {
                AddFont(font);
            }
        }

        private static void AddFont(Type type)
        {
            string fontName = (string)type!.GetField("Name")!.GetValue(null)!;
            string fontJSONPath = (string)type!.GetField("JSON")!.GetValue(null)!;
            FieldInfo fontPNGField = type.GetField("PNG")!;
            Resources.Fonts.Add(fontName, MCSDFJSON.GetFontJson(fontJSONPath)!);

            AddTexture(fontPNGField);
        }
        #endregion
        #region cubemaps
        private static void AddCubemaps()
        {
            foreach (var map in typeof(ResourcePaths.Cubemaps).GetNestedTypes())
                AddCubemap(map);
        }
        private static void AddCubemap(Type type)
        {
            // get the cubemap information
            string cubemapName = (string)type!.GetField("Name")!.GetValue(null)!;

            string rightSide = (string)type!.GetField("Right")!.GetValue(null)!;
            string leftSide = (string)type!.GetField("Left")!.GetValue(null)!;
            string topSide = (string)type!.GetField("Top")!.GetValue(null)!;
            string bottomSide = (string)type!.GetField("Bottom")!.GetValue(null)!;
            string backSide = (string)type!.GetField("Back")!.GetValue(null)!;
            string frontSide = (string)type!.GetField("Front")!.GetValue(null)!;


            Texture[] textures =
                [
                    Texture.LoadFromFile(rightSide),
                    Texture.LoadFromFile(leftSide),
                    Texture.LoadFromFile(topSide),
                    Texture.LoadFromFile(bottomSide),
                    Texture.LoadFromFile(backSide),
                    Texture.LoadFromFile(frontSide),
                ];


            Logger.Log($"Loading {LogColors.Green("Cubemap")} {LogColors.BrightWhite(cubemapName)}", LogLevel.Detail);

            Resources.Cubemaps.Add(cubemapName, new(textures));
            Resources.Cubemaps[cubemapName].Init();
        }
        #endregion
    }
}
]]></description><link>api\resourcecontroller.cs.html</link><guid isPermaLink="false">API/ResourceController.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Resources.cs]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;
using OpenglTestConsole.Classes.API.Rendering.Shaders.Compute;
using OpenglTestConsole.Classes.API.Rendering.Textures;
using static OpenglTestConsole.Classes.API.JSON.MCSDFJSON;

namespace OpenglTestConsole.Classes.API
{
    public static class Resources
    {
        public static Dictionary&lt;string, Texture&gt; Textures { get; set; } = new();
        public static Dictionary&lt;string, Shader&gt; Shaders { get; set; } = new();
        public static Dictionary&lt;string, ComputeShader&gt; CompShaders { get; set; } = new();
        public static Dictionary&lt;string, FontJson&gt; Fonts { get; set; } = new();
        public static Dictionary&lt;string, Cubemap&gt; Cubemaps { get; set; } = new();
    }
}
]]></description><link>api\resources.cs.html</link><guid isPermaLink="false">API/Resources.cs.md</guid><pubDate>Fri, 30 May 2025 20:12:31 GMT</pubDate></item><item><title><![CDATA[Scene.cs]]></title><description><![CDATA[ 
 <br>using System.Diagnostics;
using OpenglTestConsole.Classes.API.Rendering;
using OpenglTestConsole.Classes.API.Rendering.MeshClasses;
using OpenTK.Windowing.Common;

namespace OpenglTestConsole.Classes.API
{
    public class Scene
    { // i am going for a threejs like api
        public static List&lt;Light&gt; Lights { get; set; } = new();
        public static Camera Camera { get; set; } = new Camera(800, 600);
        public Stopwatch Timer = new Stopwatch();
        private List&lt;List&lt;Mesh&gt;&gt; renderList = [];

        public void Add(Mesh mesh) =&gt; renderList.Add([mesh]);

        public void Add(List&lt;Mesh&gt; mesh) =&gt; renderList.Add(mesh);

        public Scene()
        {
            Timer = new Stopwatch();
            Timer.Start();
        }

        public void Init(List&lt;RenderScript&gt; renderScripts, Camera? camera = null)
        {
            if (camera != null)
                Camera = camera;

            foreach (RenderScript script in renderScripts)
            {
                script.Camera = Camera;
                script.Timer = Timer;
                script.Scene = this;

                script.Init();
            }
        }

        public void Render(
            List&lt;RenderScript&gt; renderScripts,
            FrameEventArgs args,
            Camera? camera = null
        )
        {
            if (camera != null)
                Camera = camera;

            foreach (RenderScript script in renderScripts)
            {
                // advance the render scripts
                script.args = args;
                script.Camera = Camera;
                script.Timer = Timer;
                script.Scene = this;

                script.Advance();
            }

            // before render
            foreach (RenderScript script in renderScripts)
            {
                // advance the render scripts
                script.args = args;
                script.Camera = Camera;
                script.Timer = Timer;
                script.Scene = this;

                script.BeforeRender();
            }

            // render the meshes added by the render scripts
            renderList.ForEach(scriptRenders =&gt; scriptRenders.ForEach(mesh =&gt; mesh?.Render()));

            // after render
            foreach (RenderScript script in renderScripts)
            {
                // advance the render scripts
                script.args = args;
                script.Camera = Camera;
                script.Timer = Timer;
                script.Scene = this;

                script.AfterRender();
            }
        }
    }
}
]]></description><link>api\scene.cs.html</link><guid isPermaLink="false">API/Scene.cs.md</guid><pubDate>Fri, 30 May 2025 20:11:46 GMT</pubDate></item><item><title><![CDATA[Program.cs]]></title><description><![CDATA[ 
 <br>global using OpenTK.Graphics.OpenGL;
using OpenglTestConsole.Classes;
using OpenglTestConsole.Classes.API.Misc;
using OpenglTestConsole.Classes.Implementations.Classes;
using OpenTK.Windowing.Desktop;

namespace OpenglTestConsole
{
    public class Program
    {
        static void Main(string[] args)
        {
            Logger.Log($"Started app with arguments:\n{string.Concat(args)}", LogLevel.Info);

            Settings.Fov = 90f;

            GameWindowSettings gameWindowSettings = GameWindowSettings.Default;
            NativeWindowSettings nativeWindowSettings = new NativeWindowSettings
            {
                ClientSize = Settings.Resolution,
                Title = "OpenGL Test Console",
                DepthBits = 24,
            };

            gameWindowSettings.UpdateFrequency = 60;

            Main main = new Main(gameWindowSettings, nativeWindowSettings);
            main.Run();
        }
    }
}
]]></description><link>program.cs.html</link><guid isPermaLink="false">Program.cs.md</guid><pubDate>Fri, 30 May 2025 20:10:29 GMT</pubDate></item></channel></rss>