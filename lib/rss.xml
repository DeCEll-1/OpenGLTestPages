<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Obsidian Vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>Obsidian Vault</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 30 May 2025 19:59:14 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 30 May 2025 19:59:11 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Matrix3Extensions]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Extensions<br>
{<br>
public static class MatrixExtensions<br>
{<br>
// for god knows why using instanced rendering (or more so, passing the matrix as a layout) fucks up the rotation<br>
public static Matrix4 RotateMatrixForInstancedRendering(this Matrix4 m)<br>
{<br>
return new Matrix4(<br>
m.Row0.X,<br>
m.Row1.X,<br>
m.Row2.X,<br>
m.Row3.X,<br>
m.Row0.Y,<br>
m.Row1.Y,<br>
m.Row2.Y,<br>
m.Row3.Y,<br>
m.Row0.Z,<br>
m.Row1.Z,<br>
m.Row2.Z,<br>
m.Row3.Z,<br>
m.Row0.W,<br>
m.Row1.W,<br>
m.Row2.W,<br>
m.Row3.W<br>
);<br>
}<br>
}<br>
}]]></description><link>api\extensions\matrix3extensions.html</link><guid isPermaLink="false">API/Extensions/Matrix3Extensions.md</guid><pubDate>Fri, 30 May 2025 19:59:11 GMT</pubDate></item><item><title><![CDATA[VectorExtensions]]></title><description><![CDATA[<a class="tag" href="?query=tag:region" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#region</a> 
 <br>using System.Globalization;<br>
using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Extensions<br>
{<br>
public static class VectorExtensions<br>
{<br>
<a href=".?query=tag:region" class="tag" target="_blank" rel="noopener nofollow">#region</a> m*th<br>
public static Vector3 ToRadians(this Vector3 angles)<br>
{<br>
return new Vector3(<br>
MathHelper.DegreesToRadians(angles.X),<br>
MathHelper.DegreesToRadians(angles.Y),<br>
MathHelper.DegreesToRadians(angles.Z)<br>
);<br>
}<br>    public static Vector3 ToDegrees(this Vector3 radians)
    {
        return new Vector3(
            MathHelper.RadiansToDegrees(radians.X),
            MathHelper.RadiansToDegrees(radians.Y),
            MathHelper.RadiansToDegrees(radians.Z)
        );
    }

    /// &lt;summary&gt;
    /// top left , top right, bottom left, bottom right
    /// &lt;/summary&gt;
    /// &lt;param name="vector3"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static Vector3[] CreateSquare(this Vector3 vector)
    {
        return
        [
            new(-vector.X / 2f, vector.Y / 2f, 0f),
            new(vector.X / 2f, vector.Y / 2f, 0f),
            new(-vector.X / 2f, -vector.Y / 2f, 0f),
            new(vector.X / 2f, -vector.Y / 2f, 0f),
        ];
    }

    /// &lt;summary&gt;
    /// direction vector to eulers radians
    /// &lt;/summary&gt;
    /// &lt;param name="directionVector"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static Vector3 DirectionToEulerRadians(this Vector3 directionVector)
    {
        directionVector = Vector3.Normalize(directionVector);
        float yaw = MathF.Atan2(directionVector.X, directionVector.Z);
        float pitch = MathF.Asin(-directionVector.Y);
        float roll = 0f;
        return new Vector3(roll, pitch, yaw);
    }

    /// &lt;summary&gt;
    /// takes radians and outputs direction vector
    /// &lt;/summary&gt;
    /// &lt;param name="radians"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static Vector3 TurnToDirectionVector(this Vector3 radians)
    {
        Vector3 outVector = new Vector3();
        outVector.X = MathF.Cos(radians.Z) * MathF.Cos(radians.Y);
        outVector.Y = MathF.Sin(radians.Z) * MathF.Cos(radians.Y);
        outVector.Z = MathF.Sin(radians.Y);
        return outVector;
    }
    #endregion

    #region colors
    public static Vector4 ToVector4(this Color4 color) =&gt;
        new(color.R, color.G, color.B, color.A);

    public static Color4 ToColor4(this Vector4 color) =&gt;
        new(color.X, color.Y, color.Z, color.W);

    public static string ToHex(this Vector4 color) =&gt;
        $"{(int)(color.X * 255):X2}{(int)(color.Y * 255):X2}{(int)(color.Z * 255):X2}{(int)(color.W * 255):X2}";

    public static Vector4 FromHex(string hex) =&gt;
        new Vector4(
            byte.Parse(hex.Substring(0, 2), NumberStyles.HexNumber) / 255f,
            byte.Parse(hex.Substring(2, 2), NumberStyles.HexNumber) / 255f,
            byte.Parse(hex.Substring(4, 2), NumberStyles.HexNumber) / 255f,
            byte.Parse(hex.Substring(6, 2), NumberStyles.HexNumber) / 255f
        );
    #endregion
}
<br>}]]></description><link>api\extensions\vectorextensions.html</link><guid isPermaLink="false">API/Extensions/VectorExtensions.md</guid><pubDate>Fri, 30 May 2025 19:59:11 GMT</pubDate></item><item><title><![CDATA[LoadJsonFromFile]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.JSON<br>
{<br>
public class LoadJsonFromFile<br>
where T : class<br>
{<br>
public static T? Load(string path)<br>
{<br>
string json = System.IO.File.ReadAllText(path);<br>
T data = Newtonsoft.Json.JsonConvert.DeserializeObject(json)!;<br>
return data;<br>
}<br>
}<br>
}]]></description><link>api\json\loadjsonfromfile.html</link><guid isPermaLink="false">API/JSON/LoadJsonFromFile.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[MCSDFJson]]></title><description><![CDATA[<a class="tag" href="?query=tag:region" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#region</a> 
 <br>namespace OpenglTestConsole.Classes.API.JSON<br>
{<br>
public class MCSDFJSON<br>
{<br>
<a href=".?query=tag:region" class="tag" target="_blank" rel="noopener nofollow">#region</a> font classes<br>
public class Atlas<br>
{<br>
public string type { get; set; }<br>
public float distanceRange { get; set; }<br>
public float distanceRangeMiddle { get; set; }<br>
public float size { get; set; }<br>
public int width { get; set; }<br>
public int height { get; set; }<br>
public string yOrigin { get; set; }<br>
}<br>    public class Metrics
    {
        public float emSize { get; set; }
        public float lineHeight { get; set; }
        public float ascender { get; set; }
        public float descender { get; set; }
        public float underlineY { get; set; }
        public float underlineThickness { get; set; }
    }

    public class Bounds
    {
        public float left { get; set; }
        public float bottom { get; set; }
        public float right { get; set; }
        public float top { get; set; }
    }

    public class Glyph
    {
        public int unicode { get; set; }
        public float advance { get; set; }
        public Bounds planeBounds { get; set; } // Optional: some glyphs like space may not have this
        public Bounds atlasBounds { get; set; }
    }

    public class FontJson
    {
        public Atlas atlas { get; set; }
        public Metrics metrics { get; set; }
        public List&lt;Glyph&gt; glyphs { get; set; }
    }
    #endregion


    public static FontJson? GetFontJson(string jsonPath) =&gt;
        LoadJsonFromFile&lt;FontJson&gt;.Load(jsonPath)!;
}
<br>}]]></description><link>api\json\mcsdfjson.html</link><guid isPermaLink="false">API/JSON/MCSDFJson.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[EasingFunctions]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Misc<br>
{ // source: <a rel="noopener nofollow" class="external-link" href="https://gist.github.com/Kryzarel/bba64622057f21a1d6d44879f9cd7bd4#file-easingfunctions-cs" target="_blank">https://gist.github.com/Kryzarel/bba64622057f21a1d6d44879f9cd7bd4#file-easingfunctions-cs</a><br>
// Made with the help of this great post: <a rel="noopener nofollow" class="external-link" href="https://joshondesign.com/2013/03/01/improvedEasingEquations" target="_blank">https://joshondesign.com/2013/03/01/improvedEasingEquations</a><br>// --------------------------------- Other Related Links --------------------------------------------------------------------
// Original equations, bad formulation:	https://github.com/danro/jquery-easing/blob/master/jquery.easing.js
// A few equations, very simplified:	https://gist.github.com/gre/1650294
// Easings.net equations, simplified:	https://github.com/ai/easings.net/blob/master/src/easings/easingsFunctions.ts

public static class EasingFunctions
{
    public static float Linear(float t) =&gt; t;

    public static float InQuad(float t) =&gt; t * t;

    public static float OutQuad(float t) =&gt; 1 - InQuad(1 - t);

    public static float InOutQuad(float t)
    {
        if (t &lt; 0.5)
            return InQuad(t * 2) / 2;
        return 1 - InQuad((1 - t) * 2) / 2;
    }

    public static float InCubic(float t) =&gt; t * t * t;

    public static float OutCubic(float t) =&gt; 1 - InCubic(1 - t);

    public static float InOutCubic(float t)
    {
        if (t &lt; 0.5)
            return InCubic(t * 2) / 2;
        return 1 - InCubic((1 - t) * 2) / 2;
    }

    public static float InQuart(float t) =&gt; t * t * t * t;

    public static float OutQuart(float t) =&gt; 1 - InQuart(1 - t);

    public static float InOutQuart(float t)
    {
        if (t &lt; 0.5)
            return InQuart(t * 2) / 2;
        return 1 - InQuart((1 - t) * 2) / 2;
    }

    public static float InQuint(float t) =&gt; t * t * t * t * t;

    public static float OutQuint(float t) =&gt; 1 - InQuint(1 - t);

    public static float InOutQuint(float t)
    {
        if (t &lt; 0.5)
            return InQuint(t * 2) / 2;
        return 1 - InQuint((1 - t) * 2) / 2;
    }

    public static float InSine(float t) =&gt; 1 - (float)Math.Cos(t * Math.PI / 2);

    public static float OutSine(float t) =&gt; (float)Math.Sin(t * Math.PI / 2);

    public static float InOutSine(float t) =&gt; (float)(Math.Cos(t * Math.PI) - 1) / -2;

    public static float InExpo(float t) =&gt; (float)Math.Pow(2, 10 * (t - 1));

    public static float OutExpo(float t) =&gt; 1 - InExpo(1 - t);

    public static float InOutExpo(float t)
    {
        if (t &lt; 0.5)
            return InExpo(t * 2) / 2;
        return 1 - InExpo((1 - t) * 2) / 2;
    }

    public static float InCirc(float t) =&gt; -((float)Math.Sqrt(1 - t * t) - 1);

    public static float OutCirc(float t) =&gt; 1 - InCirc(1 - t);

    public static float InOutCirc(float t)
    {
        if (t &lt; 0.5)
            return InCirc(t * 2) / 2;
        return 1 - InCirc((1 - t) * 2) / 2;
    }

    public static float InElastic(float t) =&gt; 1 - OutElastic(1 - t);

    public static float OutElastic(float t)
    {
        float p = 0.3f;
        return (float)Math.Pow(2, -10 * t) * (float)Math.Sin((t - p / 4) * (2 * Math.PI) / p)
            + 1;
    }

    public static float InOutElastic(float t)
    {
        if (t &lt; 0.5)
            return InElastic(t * 2) / 2;
        return 1 - InElastic((1 - t) * 2) / 2;
    }

    public static float InBack(float t)
    {
        float s = 1.70158f;
        return t * t * ((s + 1) * t - s);
    }

    public static float OutBack(float t) =&gt; 1 - InBack(1 - t);

    public static float InOutBack(float t)
    {
        if (t &lt; 0.5)
            return InBack(t * 2) / 2;
        return 1 - InBack((1 - t) * 2) / 2;
    }

    public static float InBounce(float t) =&gt; 1 - OutBounce(1 - t);

    public static float OutBounce(float t)
    {
        float div = 2.75f;
        float mult = 7.5625f;

        if (t &lt; 1 / div)
        {
            return mult * t * t;
        }
        else if (t &lt; 2 / div)
        {
            t -= 1.5f / div;
            return mult * t * t + 0.75f;
        }
        else if (t &lt; 2.5 / div)
        {
            t -= 2.25f / div;
            return mult * t * t + 0.9375f;
        }
        else
        {
            t -= 2.625f / div;
            return mult * t * t + 0.984375f;
        }
    }

    public static float InOutBounce(float t)
    {
        if (t &lt; 0.5)
            return InBounce(t * 2) / 2;
        return 1 - InBounce((1 - t) * 2) / 2;
    }
}
<br>}]]></description><link>api\misc\easingfunctions.html</link><guid isPermaLink="false">API/Misc/EasingFunctions.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[Logger]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Misc<br>
{<br>
public class Logger<br>
{<br>
public static void Log(string info, LogLevel level)<br>
{<br>
switch (level)<br>
{<br>
case LogLevel.Info:<br>
Log(info, LogColors.BRIGHT_BLUE);<br>
break;<br>
case LogLevel.Detail:<br>
Log(info, LogColors.BRIGHT_BLACK);<br>
break;<br>
case LogLevel.Warning:<br>
Log(info, LogColors.BRIGHT_YELLOW);<br>
break;<br>
case LogLevel.Error:<br>
Log(info, LogColors.BRIGHT_RED);<br>
break;<br>
default:<br>
Log(info, LogColors.BRIGHT_WHITE);<br>
break;<br>
}<br>
// since we change the color when we log, logging without us changing color means the app crashed, so we should set the color to red<br>
Console.ForegroundColor = ConsoleColor.Red;<br>
}<br>    public static void Log(string info, string color)
    {
        // replace return to normals with the current color so we can change the color of texts
        Console.WriteLine(color + info.Replace(LogColors.NORMAL, color));
    }
}

public enum LogLevel
{
    Info,
    Detail,
    Warning,
    Error,
}

public class LogColors
{
    // https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
    #region Colors
    public static string NORMAL = Console.IsOutputRedirected ? "" : "RETURN_TO_NORMAL";
    public static string BLACK = Console.IsOutputRedirected ? "" : "\x1b[30m";
    public static string RED = Console.IsOutputRedirected ? "" : "\x1b[31m";
    public static string GREEN = Console.IsOutputRedirected ? "" : "\x1b[32m";
    public static string YELLOW = Console.IsOutputRedirected ? "" : "\x1b[33m";
    public static string BLUE = Console.IsOutputRedirected ? "" : "\x1b[34m";
    public static string MAGENTA = Console.IsOutputRedirected ? "" : "\x1b[35m";
    public static string CYAN = Console.IsOutputRedirected ? "" : "\x1b[36m";
    public static string WHITE = Console.IsOutputRedirected ? "" : "\x1b[37m";
    public static string BRIGHT_BLACK = Console.IsOutputRedirected ? "" : "\x1b[90m";
    public static string BRIGHT_RED = Console.IsOutputRedirected ? "" : "\x1b[91m";
    public static string BRIGHT_GREEN = Console.IsOutputRedirected ? "" : "\x1b[92m";
    public static string BRIGHT_YELLOW = Console.IsOutputRedirected ? "" : "\x1b[93m";
    public static string BRIGHT_BLUE = Console.IsOutputRedirected ? "" : "\x1b[94m";
    public static string BRIGHT_MAGENTA = Console.IsOutputRedirected ? "" : "\x1b[95m";
    public static string BRIGHT_CYAN = Console.IsOutputRedirected ? "" : "\x1b[96m";
    public static string BRIGHT_WHITE = Console.IsOutputRedirected ? "" : "\x1b[97m";
    public static string BLACK_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[40m";
    public static string RED_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[41m";
    public static string GREEN_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[42m";
    public static string YELLOW_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[43m";
    public static string BLUE_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[44m";
    public static string MAGENTA_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[45m";
    public static string CYAN_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[46m";
    public static string WHITE_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[47m";
    public static string BRIGHT_BLACK_BACKGROUND = Console.IsOutputRedirected
        ? ""
        : "\x1b[100m";
    public static string BRIGHT_RED_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[101m";
    public static string BRIGHT_GREEN_BACKGROUND = Console.IsOutputRedirected
        ? ""
        : "\x1b[102m";
    public static string BRIGHT_YELLOW_BACKGROUND = Console.IsOutputRedirected
        ? ""
        : "\x1b[103m";
    public static string BRIGHT_BLUE_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[104m";
    public static string BRIGHT_MAGENTA_BACKGROUND = Console.IsOutputRedirected
        ? ""
        : "\x1b[105m";
    public static string BRIGHT_CYAN_BACKGROUND = Console.IsOutputRedirected ? "" : "\x1b[106m";
    public static string BRIGHT_WHITE_BACKGROUND = Console.IsOutputRedirected
        ? ""
        : "\x1b[107m";
    #endregion

    #region AutoGenFunctions
    public static string Black(object source) =&gt; BLACK + source.ToString() + NORMAL;

    public static string Red(object source) =&gt; RED + source.ToString() + NORMAL;

    public static string Green(object source) =&gt; GREEN + source.ToString() + NORMAL;

    public static string Yellow(object source) =&gt; YELLOW + source.ToString() + NORMAL;

    public static string Blue(object source) =&gt; BLUE + source.ToString() + NORMAL;

    public static string Magenta(object source) =&gt; MAGENTA + source.ToString() + NORMAL;

    public static string Cyan(object source) =&gt; CYAN + source.ToString() + NORMAL;

    public static string White(object source) =&gt; WHITE + source.ToString() + NORMAL;

    public static string BrightBlack(object source) =&gt;
        BRIGHT_BLACK + source.ToString() + NORMAL;

    public static string BrightRed(object source) =&gt; BRIGHT_RED + source.ToString() + NORMAL;

    public static string BrightGreen(object source) =&gt;
        BRIGHT_GREEN + source.ToString() + NORMAL;

    public static string BrightYellow(object source) =&gt;
        BRIGHT_YELLOW + source.ToString() + NORMAL;

    public static string BrightBlue(object source) =&gt; BRIGHT_BLUE + source.ToString() + NORMAL;

    public static string BrightMagenta(object source) =&gt;
        BRIGHT_MAGENTA + source.ToString() + NORMAL;

    public static string BrightCyan(object source) =&gt; BRIGHT_CYAN + source.ToString() + NORMAL;

    public static string BrightWhite(object source) =&gt;
        BRIGHT_WHITE + source.ToString() + NORMAL;

    public static string BlackBackground(object source) =&gt;
        BLACK_BACKGROUND + source.ToString() + NORMAL;

    public static string RedBackground(object source) =&gt;
        RED_BACKGROUND + source.ToString() + NORMAL;

    public static string GreenBackground(object source) =&gt;
        GREEN_BACKGROUND + source.ToString() + NORMAL;

    public static string YellowBackground(object source) =&gt;
        YELLOW_BACKGROUND + source.ToString() + NORMAL;

    public static string BlueBackground(object source) =&gt;
        BLUE_BACKGROUND + source.ToString() + NORMAL;

    public static string MagentaBackground(object source) =&gt;
        MAGENTA_BACKGROUND + source.ToString() + NORMAL;

    public static string CyanBackground(object source) =&gt;
        CYAN_BACKGROUND + source.ToString() + NORMAL;

    public static string WhiteBackground(object source) =&gt;
        WHITE_BACKGROUND + source.ToString() + NORMAL;

    public static string BrightBlackBackground(object source) =&gt;
        BRIGHT_BLACK_BACKGROUND + source.ToString() + NORMAL;

    public static string BrightRedBackground(object source) =&gt;
        BRIGHT_RED_BACKGROUND + source.ToString() + NORMAL;

    public static string BrightGreenBackground(object source) =&gt;
        BRIGHT_GREEN_BACKGROUND + source.ToString() + NORMAL;

    public static string BrightYellowBackground(object source) =&gt;
        BRIGHT_YELLOW_BACKGROUND + source.ToString() + NORMAL;

    public static string BrightBlueBackground(object source) =&gt;
        BRIGHT_BLUE_BACKGROUND + source.ToString() + NORMAL;

    public static string BrightMagentaBackground(object source) =&gt;
        BRIGHT_MAGENTA_BACKGROUND + source.ToString() + NORMAL;

    public static string BrightCyanBackground(object source) =&gt;
        BRIGHT_CYAN_BACKGROUND + source.ToString() + NORMAL;

    public static string BrightWhiteBackground(object source) =&gt;
        BRIGHT_WHITE_BACKGROUND + source.ToString() + NORMAL;
    #endregion

    #region Functions
    public static string Surround(string source, string surroundValue)
    {
        return surroundValue + source + NORMAL;
    }
    #endregion
}
<br>}]]></description><link>api\misc\logger.html</link><guid isPermaLink="false">API/Misc/Logger.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[MathMisc]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Misc<br>
{<br>
public class MathMisc<br>
{<br>
public static float PI = (float)Math.PI;<br>    public static float Cosf(double degrees) =&gt; (float)Math.Cos(degrees * Math.PI / 180f);

    public static float Sinf(double degrees) =&gt; (float)Math.Sin(degrees * Math.PI / 180f);

    public static float Atan2f(double x, double y) =&gt;
        (float)Math.Atan2(x * Math.PI / 180f, y * Math.PI / 180f);

    public static float Asinf(double degrees) =&gt; (float)Math.Asin(degrees * Math.PI / 180f);

    public static float Atan2fRad(double x, double y) =&gt; (float)Math.Atan2(x, y);

    public static float AsinfRad(double x) =&gt; (float)Math.Asin(x);

    public static float CosfRad(double x) =&gt; (float)Math.Cos(x);

    public static float SinfRad(double x) =&gt; (float)Math.Sin(x);
}
<br>}]]></description><link>api\misc\mathmisc.html</link><guid isPermaLink="false">API/Misc/MathMisc.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[RenderMisc]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Textures;<br>
using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Misc<br>
{<br>
public class RenderMisc<br>
{<br>
public static Vector2[] DefaultTextureCoordinates<br>
{<br>
get<br>
{<br>
return<br>
[<br>
new Vector2(0f, 1f),<br>
new Vector2(1f, 1f),<br>
new Vector2(0f, 0f),<br>
new Vector2(1f, 0f),<br>
];<br>
}<br>
}<br>    public static Texture GetScreenTexture()
    {
        int[] k = new int[4];

        GL.GetInteger(GetIndexedPName.Viewport, 0, k);

        Vector2i size = new(k[2], k[3]);

        byte[] output = new byte[
            4 *
            size.X *
            size.Y
        ];

        unsafe
        {
            fixed (byte* outputPtr = output)
            {
                GL.ReadPixels(
                    0,
                    0,
                    size.X,
                    size.Y,
                    PixelFormat.Rgba,
                    PixelType.UnsignedByte,
                    (IntPtr)outputPtr
                );
            }
        }

        Texture tex = Texture.LoadFromBytes(output, k[2], k[3]);

        return tex;
    }
}
<br>}]]></description><link>api\misc\rendermisc.html</link><guid isPermaLink="false">API/Misc/RenderMisc.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[Cube]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering.Geometries<br>
{<br>
internal class Cube : Geometry3D<br>
{<br>
public Vector3 shape { get; private set; }<br>    public Cube(Vector3 shape)
    {
        this.shape = shape;
        Init();
    }

    private void Init()
    {
        (this.Vertices, this.Normals, this.TexCoords, this.Indices) = GetCube();
    }

    private (
        Vector3[] vertices,
        Vector3[] normals,
        Vector2[] texCoords,
        uint[] indices
    ) GetCube()
    {
        List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();
        List&lt;Vector3&gt; normals = new List&lt;Vector3&gt;();
        List&lt;Vector2&gt; texCoords = new List&lt;Vector2&gt;();
        List&lt;uint&gt; indices = new List&lt;uint&gt;();
        float x = shape.X;
        float y = shape.Y;
        float z = shape.Z;

        float xOffset = shape.X / 2f;
        float yOffset = shape.Y / 2f;
        float zOffset = shape.Z / 2f;

        Square front = new Square(new Vector2(x, y));
        Square back = new Square(new Vector2(x, y));
        Square left = new Square(new Vector2(z, y));
        Square right = new Square(new Vector2(z, y));
        Square top = new Square(new Vector2(x, z));
        Square bottom = new Square(new Vector2(x, z));

        Transform dummy = new Transform();
        dummy.Position.Z = -zOffset; // front
        dummy.Rotation.Z = 180;
        dummy.UpdateMatrix();
        front.ApplyTransformation(dummy.GetModelMatrix());
        dummy.Reset();

        dummy.Position.Z = zOffset;
        dummy.UpdateMatrix();
        back.ApplyTransformation(dummy.GetModelMatrix());
        dummy.Reset();

        dummy.Position.X = -xOffset;
        dummy.Rotation.Z = -90;
        dummy.UpdateMatrix();
        left.ApplyTransformation(dummy.GetModelMatrix());
        dummy.Reset();

        dummy.Position.X = xOffset;
        dummy.Rotation.Z = 90;
        dummy.UpdateMatrix();
        right.ApplyTransformation(dummy.GetModelMatrix());
        dummy.Reset();

        dummy.Position.Y = yOffset;
        dummy.Rotation.Y = -90;
        dummy.UpdateMatrix();
        top.ApplyTransformation(dummy.GetModelMatrix());
        dummy.Reset();

        dummy.Position.Y = -yOffset;
        dummy.Rotation.Y = 90;
        dummy.UpdateMatrix();
        bottom.ApplyTransformation(dummy.GetModelMatrix());

        MergedGeometry merged = Geometry3D.MergeGeometries(
            [front, back, left, right, top, bottom]
        );

        vertices.AddRange(merged.Vertices);
        normals.AddRange(merged.Normals);
        texCoords.AddRange(merged.TexCoords);
        indices.AddRange(merged.Indices);

        return (vertices.ToArray(), normals.ToArray(), texCoords.ToArray(), indices.ToArray());
    }
}
<br>}]]></description><link>api\rendering\geometries\cube.html</link><guid isPermaLink="false">API/Rendering/Geometries/Cube.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[Cylinder]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;<br>
using OpenglTestConsole.Classes.API.Rendering.MeshClasses;<br>
using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering.Geometries<br>
{<br>
public class Cylinder : Geometry3D<br>
{<br>
private int StackCount;<br>
private int SectorCount;<br>
private float Height;<br>
private float Radius;<br>    // its not that hard to draw a FUCKİNG CYLİNDER
    // YOU NEED TO DRAW A CİRCLE
    // sin cos gives dot from angle
    // then you star from angle 0, then increase it by 360/sector count

    public Cylinder(int StackCount, int SectorCount, float Height, float Radius)
    {
        this.StackCount = StackCount;
        this.SectorCount = SectorCount;
        this.Height = Height;
        this.Radius = Radius;
        Init();
    }

    private void Init()
    {
        (this.Vertices, this.Normals, this.TexCoords, this.Indices) = GetCylinder();
    }

    public override void Apply(BufferManager BufferManager)
    {
        BufferManager.SetVector3(Vertices, 0);
        BufferManager.SetVector3(Normals, 1);
        BufferManager.SetVector2(TexCoords, 2);
        BufferManager.SetIndices(Indices);
    }

    private (
        Vector3[] vertices,
        Vector3[] normals,
        Vector2[] texCoords,
        uint[] indices
    ) GetCylinder()
    {
        List&lt;Vector3&gt; unitVertices = GetUnitVertices(SectorCount);

        List&lt;Vector3&gt; vertices = new();
        List&lt;Vector3&gt; normals = new();
        List&lt;Vector2&gt; texCoords = new();

        // put side vertices to arrays
        for (int i = 0; i &lt;= StackCount; i++)
        {
            float stackStep = Height / StackCount;
            float h = -Height / 2.0f + i * stackStep;
            // t goes from 1.0 down to 0.0 as i goes from 0 to StackCount
            float t = 1.0f - (float)i / StackCount;

            for (int j = 0; j &lt; SectorCount; j++)
            {
                Vector3 unit = unitVertices[j];

                vertices.Add(
                    new(
                        unit.X * Radius, // vx
                        unit.Y * Radius, // vy
                        h // vz
                    )
                );

                // normal vector
                normals.Add(
                    new(
                        unit.X, // nx
                        unit.Y, // ny
                        unit.Z // nz
                    )
                );

                // texture coordinate
                texCoords.Add(
                    new(
                        (float)(j / (float)SectorCount), // s
                        t // t
                    )
                );
            }
        }

        #region top and bottom vertices
        // bottom Center point
        float lidHeight = -(Height / 2f);
        float nz = -1;
        vertices.Add(new Vector3(0, 0, lidHeight));
        normals.Add(new Vector3(0, 0, nz));
        texCoords.Add(new Vector2(0.5f, 0.5f));

        // top center point
        lidHeight = Height / 2f;
        nz = -1;
        vertices.Add(new Vector3(0, 0, lidHeight));
        normals.Add(new Vector3(0, 0, nz));
        texCoords.Add(new Vector2(0.5f, 0.5f));
        #endregion

        List&lt;uint&gt; indices = new List&lt;uint&gt;();
        uint uintSectorCount = Convert.ToUInt32(SectorCount);
        uint uintStackCount = Convert.ToUInt32(StackCount);

        #region side indices

        for (uint i = 0; i &lt; StackCount; ++i)
        {
            uint k1 = i * uintSectorCount; // beginning of current stack
            uint k2 = k1 + uintSectorCount; // beginning of next stack

            for (int j = 0; j &lt; SectorCount; j++, ++k1, ++k2)
            {
                // First triangle of quad
                indices.Add(k1);
                indices.Add(k1 + 1);
                indices.Add(k2);

                // 0 2 5
                // Second triangle of quad
                if (j + 1 != SectorCount)
                { // normal stuff
                    indices.Add(k2); // 5
                    indices.Add(k1 + 1); // 3
                    indices.Add(k2 + 1); // 6
                }
                else
                { // we need 3 0 and 2
                    indices.Add(k1); // 2
                    indices.Add(uintSectorCount * i); // 0
                    indices.Add(k1 + 1); // 3
                    //indices.Add(Math.Min(k1 - uintSectorCount, 0));
                    //indices.Add((uintSectorCount * i));
                }
            }
        }

        #endregion

        #region top and bottom indices

        #region top

        uint bottomIndex = (uint)(vertices.Count - 2); // bottom center point
        uint bottomK1 = 0;
        uint bottomK2 = 1;

        for (int j = 0; j &lt; SectorCount; j++, bottomK1++, bottomK2++)
        {
            // First triangle
            // 3 is the next stacks starting index, which is the number of sectors we have
            // so it not being 3 means we are in the same stack
            if (bottomK2 != SectorCount)
                indices.Add(bottomK2);
            else
                indices.Add(bottomK2 - uintSectorCount); // 0
            indices.Add(bottomK1);
            indices.Add(bottomIndex); // center point
        }

        #endregion

        #region bottom

        uint topIndex = (uint)(vertices.Count - 1); // top center point
        uint topK1 = uintSectorCount * uintStackCount; // beginning of current stack
        uint topK2 = topK1 + 1; // beginning of next stack

        for (int j = 0; j &lt; SectorCount; j++, topK1++, topK2++)
        {
            // First triangle of quad
            indices.Add(topIndex); // center point
            indices.Add(topK1);
            // 3 is the next stacks starting index, which is the number of sectors we have
            // so it not being 3 means we are in the same stack
            if (topK2 != vertices.Count - 2)
                indices.Add(topK2);
            else
                indices.Add(uintSectorCount * uintStackCount); // 0
        }

        #endregion

        #endregion

        return (vertices.ToArray(), normals.ToArray(), texCoords.ToArray(), indices.ToArray());
    }

    private List&lt;Vector3&gt; GetUnitVertices(int sectorCount)
    {
        List&lt;Vector3&gt; unitVertices = new();
        for (int i = 0; i &lt; sectorCount; i++)
        {
            float currentAngle = i * (360f / sectorCount); // current angle in degrees

            float x = MathMisc.Cosf(currentAngle);
            float y = MathMisc.Sinf(currentAngle);

            unitVertices.Add(new(x, y, 0));
        }

        return unitVertices;
    }
}
<br>}]]></description><link>api\rendering\geometries\cylinder.html</link><guid isPermaLink="false">API/Rendering/Geometries/Cylinder.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[Geometry3D]]></title><description><![CDATA[<a class="tag" href="?query=tag:region" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#region</a> <a class="tag" href="?query=tag:endregion" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#endregion</a> 
 <br>using OpenglTestConsole.Classes.API.Rendering.MeshClasses;<br>
using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering.Geometries<br>
{<br>
public abstract class Geometry3D<br>
{<br>
public int size;<br>
<a href=".?query=tag:region" class="tag" target="_blank" rel="noopener nofollow">#region</a> length<br>
public int IndicesLength { get =&gt; this.Indices.Length; }<br>
public int VerticesLength { get =&gt; this.Vertices.Length; }<br>
public int NormalsLength { get =&gt; this.Normals.Length; }<br>
public int TexCoordsLength { get =&gt; this.TexCoords.Length; }<br>
<a href=".?query=tag:endregion" class="tag" target="_blank" rel="noopener nofollow">#endregion</a><br>    public uint[] Indices = [];

    public Vector3[] Vertices = Array.Empty&lt;Vector3&gt;();
    public Vector3[] Normals = Array.Empty&lt;Vector3&gt;();
    public Vector2[] TexCoords = Array.Empty&lt;Vector2&gt;();

    public virtual void Apply(BufferManager BufferManager)
    {
        size = this.VerticesLength; // almost forgor this lmao
        BufferManager.SetVector3(this.Vertices, 0);
        BufferManager.SetVector3(this.Normals, 1);
        BufferManager.SetVector2(this.TexCoords, 2);
        BufferManager.SetIndices(this.Indices);
    }

    public void ApplyTransformation(Matrix4 transform)
    {
        // Transform vertex positions
        for (int i = 0; i &lt; Vertices.Length; i++)
        {
            Vertices[i] = Vector3.TransformPosition(Vertices[i], transform);
        }

        // Transform normals (ignore translation)
        for (int i = 0; i &lt; Normals.Length; i++)
        {
            Normals[i] = Vector3.TransformNormal(Normals[i], transform);
            Normals[i] = Normals[i].Normalized();
        }
    }

    public static MergedGeometry MergeGeometries(Geometry3D[] geometries)
    {
        MergedGeometry mergedGeometry = new MergedGeometry();
        List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();
        List&lt;Vector3&gt; normals = new List&lt;Vector3&gt;();
        List&lt;Vector2&gt; texCoords = new List&lt;Vector2&gt;();
        List&lt;uint&gt; indices = new List&lt;uint&gt;();
        uint indexOffset = 0;
        foreach (var geometry in geometries)
        {
            vertices.AddRange(geometry.Vertices);
            normals.AddRange(geometry.Normals);
            texCoords.AddRange(geometry.TexCoords);
            indices.AddRange(geometry.Indices.Select(i =&gt; i + indexOffset));
            indexOffset += (uint)geometry.Vertices.Length;
        }
        mergedGeometry.Vertices = vertices.ToArray();
        mergedGeometry.Normals = normals.ToArray();
        mergedGeometry.TexCoords = texCoords.ToArray();
        mergedGeometry.Indices = indices.ToArray();
        return mergedGeometry;
    }
}
<br>}]]></description><link>api\rendering\geometries\geometry3d.html</link><guid isPermaLink="false">API/Rendering/Geometries/Geometry3D.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[MergedGeometry]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Rendering.Geometries<br>
{<br>
public class MergedGeometry : Geometry3D<br>
{<br>
public MergedGeometry() { }<br>
}<br>
}]]></description><link>api\rendering\geometries\mergedgeometry.html</link><guid isPermaLink="false">API/Rendering/Geometries/MergedGeometry.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[Skybox]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;<br>
using System.Threading.Tasks;<br>namespace OpenglTestConsole.Classes.API.Rendering.Geometries<br>
{<br>
public class Skybox : Geometry3D<br>
{<br>
public Skybox()<br>
{<br>
Init();<br>
}<br>
private void Init()<br>
{<br>
(this.Vertices, this.Normals, this.TexCoords, this.Indices) = GetSkybox();<br>
}<br>    private (
        Vector3[] vertices,
        Vector3[] normals,
        Vector2[] texCoords,
        uint[] indices
    ) GetSkybox()
    {
        return (
            vertices:
            [
                new(-1.0f,  1.0f, -1.0f),
                new(-1.0f, -1.0f, -1.0f),
                new( 1.0f, -1.0f, -1.0f),
                new( 1.0f, -1.0f, -1.0f),
                new( 1.0f,  1.0f, -1.0f),
                new(-1.0f,  1.0f, -1.0f),

                new(-1.0f, -1.0f,  1.0f),
                new(-1.0f, -1.0f, -1.0f),
                new(-1.0f,  1.0f, -1.0f),
                new(-1.0f,  1.0f, -1.0f),
                new(-1.0f,  1.0f,  1.0f),
                new(-1.0f, -1.0f,  1.0f),

                new( 1.0f, -1.0f, -1.0f),
                new( 1.0f, -1.0f,  1.0f),
                new( 1.0f,  1.0f,  1.0f),
                new( 1.0f,  1.0f,  1.0f),
                new( 1.0f,  1.0f, -1.0f),
                new( 1.0f, -1.0f, -1.0f),

                new(-1.0f, -1.0f,  1.0f),
                new(-1.0f,  1.0f,  1.0f),
                new( 1.0f,  1.0f,  1.0f),
                new( 1.0f,  1.0f,  1.0f),
                new( 1.0f, -1.0f,  1.0f),
                new(-1.0f, -1.0f,  1.0f),

                new(-1.0f,  1.0f, -1.0f),
                new( 1.0f,  1.0f, -1.0f),
                new( 1.0f,  1.0f,  1.0f),
                new( 1.0f,  1.0f,  1.0f),
                new(-1.0f,  1.0f,  1.0f),
                new(-1.0f,  1.0f, -1.0f),

                new(-1.0f, -1.0f, -1.0f),
                new(-1.0f, -1.0f,  1.0f),
                new( 1.0f, -1.0f, -1.0f),
                new( 1.0f, -1.0f, -1.0f),
                new(-1.0f, -1.0f,  1.0f),
                new( 1.0f, -1.0f,  1.0f)
            ],
            normals: [],
            texCoords: [], // same as the vertex positions
            indices: []
            );
    }
}
<br>}]]></description><link>api\rendering\geometries\skybox.html</link><guid isPermaLink="false">API/Rendering/Geometries/Skybox.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[Sphere]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;<br>
using OpenglTestConsole.Classes.API.Rendering.MeshClasses;<br>
using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering.Geometries<br>
{<br>
public class Sphere : Geometry3D<br>
{<br>
public int SectorCount;<br>
public int StackCount;<br>
public float radius;<br>    public Sphere(int stackCount, int sectorCount, float radius)
    {
        this.StackCount = stackCount;
        this.SectorCount = sectorCount;
        this.radius = radius;
        Init();
    }

    private void Init()
    {
        (this.Vertices, this.Normals, this.TexCoords, this.Indices, _) = GetSphere();
        Transform tempTrans = new Transform();
        tempTrans.Rotation.Y = -90;
        tempTrans.UpdateMatrix();
        this.ApplyTransformation(tempTrans.GetModelMatrix());
    }

    public (
        Vector3[] vertices,
        Vector3[] normals,
        Vector2[] texCoords,
        uint[] indices,
        uint[] lineIndices
    ) GetSphere()
    {
        // make variables for quick access as we are using floats and all deez are returning doubles

        // list because itd be annoying to use arrays from the start
        List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();
        List&lt;Vector3&gt; normals = new List&lt;Vector3&gt;();
        List&lt;Vector2&gt; texCoords = new List&lt;Vector2&gt;();

        float lengthInv = 1.0f / radius;
        float sectorStep = 2 * MathMisc.PI / SectorCount;
        float stackStep = MathMisc.PI / StackCount;

        for (int i = 0; i &lt;= StackCount; i++)
        {
            float stackAngle = MathMisc.PI / 2 - i * stackStep; // starting from pi/2 to -pi/2
            float xy = radius * MathMisc.CosfRad(stackAngle); // r * cos(u)
            float z = radius * MathMisc.SinfRad(stackAngle); // r * sin(u)

            for (int j = 0; j &lt;= SectorCount; j++)
            {
                float sectorAngle = j * sectorStep; // starting from 0 to 2pi

                // vertex position (x, y, z)
                float x = xy * MathMisc.CosfRad(sectorAngle); // r * cos(u) * cos(v)
                float y = xy * MathMisc.SinfRad(sectorAngle); // r * cos(u) * sin(v)
                vertices.Add(new Vector3(x, y, z));

                float normalisedX = x * lengthInv;
                float normalisedY = y * lengthInv;
                float normalisedZ = z * lengthInv;
                normals.Add(new Vector3(normalisedX, normalisedY, normalisedZ));

                // vertex tex coord (s, t) range between [0, 1]
                float s = (float)j / SectorCount;
                float t = (float)i / StackCount;
                texCoords.Add(new Vector2(s, t));
            }
        }

        // generate CCW index list of sphere triangles
        // k1--k1+1
        // |  / |
        // | /  |
        // k2--k2+1
        List&lt;uint&gt; indices = new List&lt;uint&gt;();
        List&lt;uint&gt; lineIndices = new List&lt;uint&gt;(); // for wireframe and blabla
        for (int i = 0; i &lt; StackCount; ++i)
        {
            uint k1 = (uint)(i * (SectorCount + 1)); // beginning of current stack
            uint k2 = (uint)(k1 + SectorCount + 1); // beginning of next stack

            for (int j = 0; j &lt; SectorCount; ++j, ++k1, ++k2)
            {
                // 2 triangles per sector excluding first and last stacks
                // k1 =&gt; k2 =&gt; k1+1
                if (i != 0)
                {
                    indices.Add(k1);
                    indices.Add(k2);
                    indices.Add(k1 + 1);
                }

                // k1+1 =&gt; k2 =&gt; k2+1
                if (i != StackCount - 1)
                {
                    indices.Add(k1 + 1);
                    indices.Add(k2);
                    indices.Add(k2 + 1);
                }

                // store indices for lines
                // vertical lines for all stacks, k1 =&gt; k2
                lineIndices.Add(k1);
                lineIndices.Add(k2);
                if (i != 0) // horizontal lines except 1st stack, k1 =&gt; k+1
                {
                    lineIndices.Add(k1);
                    lineIndices.Add(k1 + 1);
                }
            }
        }

        return (
            vertices: vertices.ToArray(),
            normals: normals.ToArray(),
            texCoords: texCoords.ToArray(),
            indices: indices.ToArray(),
            lineIndices: lineIndices.ToArray()
        );
    }

    public override void Apply(BufferManager BufferManager)
    {
        base.Apply(BufferManager);
    }
}
<br>}]]></description><link>api\rendering\geometries\sphere.html</link><guid isPermaLink="false">API/Rendering/Geometries/Sphere.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[Square]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering.Geometries<br>
{<br>
internal class Square : Geometry3D<br>
{<br>
public Vector2 shape { get; private set; }<br>    public Square(Vector2 shape)
    {
        this.shape = shape;
        Init();
    }

    private void Init()
    {
        (this.Vertices, this.Normals, this.TexCoords, this.Indices) = GetPlane();
    }

    public (
        Vector3[] vertices,
        Vector3[] normals,
        Vector2[] texCoords,
        uint[] indices
    ) GetPlane()
    {
        // make variables for quick access as we are using floats and all deez are returning doubles
        // list because itd be annoying to use arrays from the start
        List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();
        List&lt;Vector3&gt; normals = new List&lt;Vector3&gt;();
        List&lt;Vector2&gt; texCoords = new List&lt;Vector2&gt;();
        float x = shape.X / 2f;
        float y = shape.Y / 2f;
        vertices.Add(new Vector3(-x, -y, 0));
        vertices.Add(new Vector3(x, -y, 0));
        vertices.Add(new Vector3(x, y, 0));
        vertices.Add(new Vector3(-x, y, 0));

        normals.Add(new Vector3(0, 0, 1));
        normals.Add(new Vector3(0, 0, 1));
        normals.Add(new Vector3(0, 0, 1));
        normals.Add(new Vector3(0, 0, 1));

        texCoords.Add(new Vector2(0, 0));
        texCoords.Add(new Vector2(1, 0));
        texCoords.Add(new Vector2(1, 1));
        texCoords.Add(new Vector2(0, 1));

        return (
            vertices.ToArray(),
            normals.ToArray(),
            texCoords.ToArray(),
            new uint[] {
                0, 1, 2,
                2, 3, 0
            }
        );
    }
}
<br>}]]></description><link>api\rendering\geometries\square.html</link><guid isPermaLink="false">API/Rendering/Geometries/Square.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[PhongMaterials]]></title><description><![CDATA[<a class="tag" href="?query=tag:region" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#region</a> 
 <br>using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering.Materials<br>
{<br>
public partial class PhongMaterial<br>
{<br>
<a href=".?query=tag:region" class="tag" target="_blank" rel="noopener nofollow">#region</a> pre made materials<br>
public static PhongMaterial Emerald =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.0215f, 0.1745f, 0.0215f),<br>
new Vector3(0.07568f, 0.61424f, 0.07568f),<br>
new Vector3(0.633f, 0.727811f, 0.633f),<br>
0.6f<br>
);<br>
public static PhongMaterial Jade =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.135f, 0.2225f, 0.1575f),<br>
new Vector3(0.54f, 0.89f, 0.63f),<br>
new Vector3(0.316228f, 0.316228f, 0.316228f),<br>
0.1f<br>
);<br>
public static PhongMaterial Obsidian =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.05375f, 0.05f, 0.06625f),<br>
new Vector3(0.18275f, 0.17f, 0.22525f),<br>
new Vector3(0.332741f, 0.328634f, 0.346435f),<br>
0.3f<br>
);<br>
public static PhongMaterial Pearl =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.25f, 0.20725f, 0.20725f),<br>
new Vector3(1f, 0.829f, 0.829f),<br>
new Vector3(0.296648f, 0.296648f, 0.296648f),<br>
0.088f<br>
);<br>
public static PhongMaterial Ruby =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.1745f, 0.01175f, 0.01175f),<br>
new Vector3(0.61424f, 0.04136f, 0.04136f),<br>
new Vector3(0.727811f, 0.626959f, 0.626959f),<br>
0.6f<br>
);<br>
public static PhongMaterial Turquoise =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.1f, 0.18725f, 0.1745f),<br>
new Vector3(0.396f, 0.74151f, 0.69102f),<br>
new Vector3(0.297254f, 0.30829f, 0.306678f),<br>
0.1f<br>
);<br>
public static PhongMaterial Brass =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.329412f, 0.223529f, 0.027451f),<br>
new Vector3(0.780392f, 0.568627f, 0.113725f),<br>
new Vector3(0.992157f, 0.941176f, 0.807843f),<br>
0.21794872f<br>
);<br>
public static PhongMaterial Bronze =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.2125f, 0.1275f, 0.054f),<br>
new Vector3(0.714f, 0.4284f, 0.18144f),<br>
new Vector3(0.393548f, 0.271906f, 0.166721f),<br>
0.2f<br>
);<br>
public static PhongMaterial Chrome =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.25f, 0.25f, 0.25f),<br>
new Vector3(0.4f, 0.4f, 0.4f),<br>
new Vector3(0.774597f, 0.774597f, 0.774597f),<br>
0.6f<br>
);<br>
public static PhongMaterial Copper =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.19125f, 0.0735f, 0.0225f),<br>
new Vector3(0.7038f, 0.27048f, 0.0828f),<br>
new Vector3(0.256777f, 0.137622f, 0.086014f),<br>
0.1f<br>
);<br>
public static PhongMaterial Gold =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.24725f, 0.1995f, 0.0745f),<br>
new Vector3(0.75164f, 0.60648f, 0.22648f),<br>
new Vector3(0.628281f, 0.555802f, 0.366065f),<br>
0.4f<br>
);<br>
public static PhongMaterial Silver =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.19225f, 0.19225f, 0.19225f),<br>
new Vector3(0.50754f, 0.50754f, 0.50754f),<br>
new Vector3(0.508273f, 0.508273f, 0.508273f),<br>
0.4f<br>
);<br>
public static PhongMaterial BlackPlastic =&gt;<br>
new PhongMaterial(<br>
new Vector3(0f, 0f, 0f),<br>
new Vector3(0.01f, 0.01f, 0.01f),<br>
new Vector3(0.5f, 0.5f, 0.5f),<br>
0.25f<br>
);<br>
public static PhongMaterial CyanPlastic =&gt;<br>
new PhongMaterial(<br>
new Vector3(0f, 0.1f, 0.06f),<br>
new Vector3(0f, 0.50980392f, 0.50980392f),<br>
new Vector3(0.50196078f, 0.50196078f, 0.50196078f),<br>
0.25f<br>
);<br>
public static PhongMaterial GreenPlastic =&gt;<br>
new PhongMaterial(<br>
new Vector3(0f, 0f, 0f),<br>
new Vector3(0.1f, 0.35f, 0.1f),<br>
new Vector3(0.45f, 0.55f, 0.45f),<br>
0.25f<br>
);<br>
public static PhongMaterial RedPlastic =&gt;<br>
new PhongMaterial(<br>
new Vector3(0f, 0f, 0f),<br>
new Vector3(0.5f, 0f, 0f),<br>
new Vector3(0.7f, 0.6f, 0.6f),<br>
0.25f<br>
);<br>
public static PhongMaterial WhitePlastic =&gt;<br>
new PhongMaterial(<br>
new Vector3(0f, 0f, 0f),<br>
new Vector3(0.55f, 0.55f, 0.55f),<br>
new Vector3(0.7f, 0.7f, 0.7f),<br>
0.25f<br>
);<br>
public static PhongMaterial YellowPlastic =&gt;<br>
new PhongMaterial(<br>
new Vector3(0f, 0f, 0f),<br>
new Vector3(0.5f, 0.5f, 0f),<br>
new Vector3(0.6f, 0.6f, 0.5f),<br>
0.25f<br>
);<br>
public static PhongMaterial BlackRubber =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.02f, 0.02f, 0.02f),<br>
new Vector3(0.01f, 0.01f, 0.01f),<br>
new Vector3(0.4f, 0.4f, 0.4f),<br>
0.078125f<br>
);<br>
public static PhongMaterial CyanRubber =&gt;<br>
new PhongMaterial(<br>
new Vector3(0f, 0.05f, 0.05f),<br>
new Vector3(0.4f, 0.5f, 0.5f),<br>
new Vector3(0.04f, 0.7f, 0.7f),<br>
0.078125f<br>
);<br>
public static PhongMaterial GreenRubber =&gt;<br>
new PhongMaterial(<br>
new Vector3(0f, 0.05f, 0f),<br>
new Vector3(0.4f, 0.5f, 0.4f),<br>
new Vector3(0.04f, 0.7f, 0.04f),<br>
0.078125f<br>
);<br>
public static PhongMaterial RedRubber =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.05f, 0f, 0f),<br>
new Vector3(0.5f, 0.4f, 0.4f),<br>
new Vector3(0.7f, 0.04f, 0.04f),<br>
0.078125f<br>
);<br>
public static PhongMaterial WhiteRubber =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.05f, 0.05f, 0.05f),<br>
new Vector3(0.5f, 0.5f, 0.5f),<br>
new Vector3(0.7f, 0.7f, 0.7f),<br>
0.078125f<br>
);<br>
public static PhongMaterial YellowRubber =&gt;<br>
new PhongMaterial(<br>
new Vector3(0.05f, 0.05f, 0f),<br>
new Vector3(0.5f, 0.5f, 0.4f),<br>
new Vector3(0.7f, 0.7f, 0.04f),<br>
0.078125f<br>
);<br>    #endregion
}
<br>}]]></description><link>api\rendering\materials\predefinedmaterials\phongmaterials.html</link><guid isPermaLink="false">API/Rendering/Materials/PreDefinedMaterials/PhongMaterials.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[MonoColorMaterial]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;<br>
using OpenglTestConsole.Generated.Paths;<br>
using OpenTK.Mathematics;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;<br>
using System.Threading.Tasks;<br>namespace OpenglTestConsole.Classes.API.Rendering.Materials<br>
{<br>
internal class MonoColorMaterial : Material<br>
{<br>
public Vector4 color = new(1);<br>
public MonoColorMaterial(Vector4 col)<br>
{<br>
this.color = col;<br>
this.Shader = Resources.Shaders[ResourcePaths.Materials.MonoColor.Name];<br>
}<br>
public override void Apply()<br>
{<br>
Shader.UniformManager.SetVector4("color", color);<br>
}<br>
}<br>
}]]></description><link>api\rendering\materials\monocolormaterial.html</link><guid isPermaLink="false">API/Rendering/Materials/MonoColorMaterial.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[PhongMaterial]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;<br>
using OpenTK.Mathematics;<br>
using OpenglTestConsole.Generated.Paths;<br>namespace OpenglTestConsole.Classes.API.Rendering.Materials<br>
{<br>
public partial class PhongMaterial : Material<br>
{<br>
// color of the ambient lightning<br>
public Vector3 Ambient { get; set; }<br>    // color of the diffuse lightning
    public Vector3 Diffuse { get; set; }

    // color of the specular lightning
    public Vector3 Specular { get; set; }

    // size of the specular light
    public float Shininess { get; set; }

    public PhongMaterial()
    {
        this.Shader = Resources.Shaders[ResourcePaths.Materials.Phong.Name];
    }

    public PhongMaterial(Vector3 ambient, Vector3 diffuse, Vector3 specular, float shininess)
    {
        this.Ambient = ambient;
        this.Diffuse = diffuse;
        this.Specular = specular;
        this.Shininess = shininess * 128f;
        this.Shader = Resources.Shaders[ResourcePaths.Materials.Phong.Name];
    }

    public override void Apply()
    {
        Shader.UniformManager.SetVector3("material.ambient", Ambient);
        Shader.UniformManager.SetVector3("material.diffuse", Diffuse);
        Shader.UniformManager.SetVector3("material.specular", Specular);
        Shader.UniformManager.SetFloat("material.shininess", Shininess);

        // update this to allow more lights
        Shader.UniformManager.SetVector3("light.position", Scene.Lights[0].Position);
        Shader.UniformManager.SetVector3("light.specular", Scene.Lights[0].Specular);
        Shader.UniformManager.SetVector3("light.diffuse", Scene.Lights[0].Diffuse);
        Shader.UniformManager.SetVector3("light.ambient", Scene.Lights[0].Ambient);

        Shader.UniformManager.SetVector3("viewPos", Scene.Camera.Position);
    }
}
<br>}]]></description><link>api\rendering\materials\phongmaterial.html</link><guid isPermaLink="false">API/Rendering/Materials/PhongMaterial.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[SkyboxMaterial]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;<br>
using OpenglTestConsole.Classes.API.Rendering.Textures;<br>
using OpenglTestConsole.Generated.Paths;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;<br>
using System.Threading.Tasks;<br>namespace OpenglTestConsole.Classes.API.Rendering.Materials<br>
{<br>
internal class SkyboxMaterial : Material<br>
{<br>
private Cubemap cubemap;<br>
public SkyboxMaterial(Cubemap cubemap)<br>
{<br>
this.Shader = Resources.Shaders[ResourcePaths.Materials.Skybox.Name];<br>
this.cubemap = cubemap;<br>
}<br>
public override void Apply()<br>
{ // set shader values here<br>
Shader.UniformManager.SetCubemap("skybox", cubemap, TextureUnit.Texture0);<br>
}<br>
}<br>
}]]></description><link>api\rendering\materials\skyboxmaterial.html</link><guid isPermaLink="false">API/Rendering/Materials/SkyboxMaterial.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[StandartMaterial]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;<br>
using System.Threading.Tasks;<br>namespace OpenglTestConsole.Classes.API.Rendering.Materials<br>
{<br>
internal class StandartMaterial : Material<br>
{<br>
public bool Wireframe { get; set; }<br>
public bool FlatShaded { get; set; }<br>    public StandartMaterial() { }
    public override void Apply()
    {
        // add shader sets here

    }
}
<br>}]]></description><link>api\rendering\materials\standartmaterial.html</link><guid isPermaLink="false">API/Rendering/Materials/StandartMaterial.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[TextureMaterial]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;<br>
using OpenTK.Mathematics;<br>
using OpenglTestConsole.Generated.Paths;<br>
using OpenglTestConsole.Classes.API.Rendering.Textures;<br>namespace OpenglTestConsole.Classes.API.Rendering.Materials<br>
{<br>
public class TextureMaterial : Material<br>
{<br>
public Texture Texture { get; set; }<br>
public Vector4 Color { get; set; } = new Vector4(1f, 1f, 1f, 1f);<br>
public TextureMaterial() { this.Shader = Resources.Shaders[ResourcePaths.Materials.Texture.Name]; }<br>
public TextureMaterial(Texture texture, Vector4? color = null)<br>
{<br>
this.Texture = texture; this.Color = color ?? new Vector4(1f, 1f, 1f, 1f);<br>
this.Shader = Resources.Shaders[ResourcePaths.Materials.Texture.Name];<br>
}<br>
public override void Apply()<br>
{<br>
Shader.UniformManager.SetTexture("material.texture", Texture, TextureUnit.Texture0);<br>
Shader.UniformManager.SetVector4("material.colMultiplier", Color);<br>
}<br>
}<br>
}]]></description><link>api\rendering\materials\texturematerial.html</link><guid isPermaLink="false">API/Rendering/Materials/TextureMaterial.md</guid><pubDate>Fri, 30 May 2025 19:59:12 GMT</pubDate></item><item><title><![CDATA[BufferManager]]></title><description><![CDATA[<a class="tag" href="?query=tag:region" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#region</a> 
 <br>using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering.MeshClasses<br>
{<br>
public partial class BufferManager<br>
{<br>
<a href=".?query=tag:region" class="tag" target="_blank" rel="noopener nofollow">#region</a> Shader<br>
private Dictionary&lt;int, int&gt; _vboCache = new(); // loc -&gt; VBO<br>    private int VertexArrayObjectPointer;
    private int _eboCache = -1; // Cache for the element buffer object (EBO)

    public BufferManager(int vao)
    {
        VertexArrayObjectPointer = vao;
    }

    public void SetVector2(
        Vector2[] vectors,
        int loc,
        BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
    )
    {
        GL.BindVertexArray(VertexArrayObjectPointer);

        if (!_vboCache.TryGetValue(loc, out int vbo))
        {
            vbo = GL.GenBuffer();
            _vboCache[loc] = vbo;

            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferData(
                BufferTarget.ArrayBuffer,
                vectors.Length * Vector2.SizeInBytes,
                vectors,
                bufferHint
            );

            GL.VertexAttribPointer(
                loc,
                2,
                VertexAttribPointerType.Float,
                false,
                Vector2.SizeInBytes,
                0
            );
            GL.EnableVertexAttribArray(loc);
        }
        else
        {
            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferSubData(
                BufferTarget.ArrayBuffer,
                IntPtr.Zero,
                vectors.Length * Vector2.SizeInBytes,
                vectors
            );
        }
    }

    public void SetVector3(
        Vector3[] vectors,
        int loc,
        BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
    )
    {
        GL.BindVertexArray(VertexArrayObjectPointer);

        if (!_vboCache.TryGetValue(loc, out int vbo))
        {
            vbo = GL.GenBuffer();
            _vboCache[loc] = vbo;

            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferData(
                BufferTarget.ArrayBuffer,
                vectors.Length * Vector3.SizeInBytes,
                vectors,
                bufferHint
            );

            GL.VertexAttribPointer(
                loc,
                3,
                VertexAttribPointerType.Float,
                false,
                Vector3.SizeInBytes,
                0
            );
            GL.EnableVertexAttribArray(loc);
        }
        else
        {
            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferSubData(
                BufferTarget.ArrayBuffer,
                IntPtr.Zero,
                vectors.Length * Vector3.SizeInBytes,
                vectors
            );
        }
    }

    public void SetVector4(
        Vector4[] vectors,
        int loc,
        BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
    )
    {
        GL.BindVertexArray(VertexArrayObjectPointer);

        if (!_vboCache.TryGetValue(loc, out int vbo))
        {
            vbo = GL.GenBuffer();
            _vboCache[loc] = vbo;

            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferData(
                BufferTarget.ArrayBuffer,
                vectors.Length * Vector4.SizeInBytes,
                vectors,
                bufferHint
            );

            GL.VertexAttribPointer(
                loc,
                4,
                VertexAttribPointerType.Float,
                false,
                Vector4.SizeInBytes,
                0
            );
            GL.EnableVertexAttribArray(loc);
        }
        else
        {
            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferSubData(
                BufferTarget.ArrayBuffer,
                IntPtr.Zero,
                vectors.Length * Vector4.SizeInBytes,
                vectors
            );
        }
    }

    public void SetColor(
        Color4[] colors,
        int loc,
        BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
    )
    {
        GL.BindVertexArray(VertexArrayObjectPointer);

        if (!_vboCache.TryGetValue(loc, out int vbo))
        {
            vbo = GL.GenBuffer();
            _vboCache[loc] = vbo;

            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferData(
                BufferTarget.ArrayBuffer,
                colors.Length * 4 * sizeof(float),
                colors,
                bufferHint
            );

            GL.VertexAttribPointer(
                loc,
                4,
                VertexAttribPointerType.Float,
                false,
                4 * sizeof(float),
                0
            );
            GL.EnableVertexAttribArray(loc);
        }
        else
        {
            GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
            GL.BufferSubData(
                BufferTarget.ArrayBuffer,
                IntPtr.Zero,
                colors.Length * 4 * sizeof(float),
                colors
            );
        }
    }

    public void SetIndices(
        uint[] indices,
        BufferUsageHint bufferHint = BufferUsageHint.StaticDraw
    )
    {
        GL.BindVertexArray(VertexArrayObjectPointer);

        if (_eboCache == -1)
        {
            _eboCache = GL.GenBuffer();
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, _eboCache);
            GL.BufferData(
                BufferTarget.ElementArrayBuffer,
                indices.Length * sizeof(uint),
                indices,
                bufferHint
            );
        }
        else
        {
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, _eboCache);
            GL.BufferSubData(
                BufferTarget.ElementArrayBuffer,
                IntPtr.Zero,
                indices.Length * sizeof(uint),
                indices
            );
        }
    }

    public void Dispose()
    {
        // Delete all VBOs
        foreach (var vbo in _vboCache.Values)
        {
            GL.DeleteBuffer(vbo);
        }

        // Delete the EBO if it exists
        if (_eboCache != -1)
        {
            GL.DeleteBuffer(_eboCache);
        }

        // Clear the cache
        _vboCache.Clear();
        _eboCache = -1;
    }

    #endregion
}
<br>}]]></description><link>api\rendering\meshclasses\buffermanager.html</link><guid isPermaLink="false">API/Rendering/MeshClasses/BufferManager.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[InstancedMesh]]></title><description><![CDATA[ 
 <br>using Newtonsoft.Json.Linq;<br>
using OpenglTestConsole.Classes.API.Extensions;<br>
using OpenglTestConsole.Classes.API.Rendering;<br>
using OpenTK.Graphics.OpenGL;<br>
using OpenTK.Mathematics;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Diagnostics.CodeAnalysis;<br>
using System.Linq;<br>
using System.Runtime.InteropServices;<br>
using System.Text;<br>
using System.Threading.Tasks;<br>namespace OpenglTestConsole.Classes.API.Rendering.MeshClasses<br>
{<br>
public partial class InstancedMesh where T : Mesh<br>
{<br>
public List Meshes { get; set; } = new();<br>
public InstancedMesh() { }<br>    public void FinishAddingElemets()
    {
        Matrix4[] matrices = new Matrix4[Meshes.Count];
        for (int i = 0; i &lt; Meshes.Count; i++)
        {
            matrices[i] = Meshes[i].Transform.GetModelMatrix();
        }
        // for GOD KNOWS WHY
        // matrix turns when i put them in the vertex shader, so i will turn them here (or chatgpt will ig idk m*th)
        Matrix4[] rotatedMatrixes = new Matrix4[matrices.Length];
        for (int i = 0; i &lt; matrices.Length; i++)
        {
            Matrix4 matrix = matrices[i];
          
            rotatedMatrixes[i] = matrix.RotateMatrixForInstancedRendering();
        }
        SetMatrix4(rotatedMatrixes, 12, 1);
    }

    public void PrepareRender(Light light)
    {
        if (Meshes.Count == 0) return;

        var shader = Meshes[0].Shader;
        shader.Use();

        if (Meshes[0] is LightEffectedMesh lightMesh)
            lightMesh.SetStaticUniforms(light); // handles light uniforms

        GL.Enable(EnableCap.CullFace); // optional: control based on mesh settings
    }
    public void EndRender() =&gt; GL.Disable(EnableCap.CullFace);

    #region render
    public void Render(PrimitiveType type = PrimitiveType.Triangles)
    {
        T ourMesh = Meshes[0];
        ourMesh.Shader.SetMatrix4("projection", ourMesh.Camera.GetProjectionMatrix());
        ourMesh.Shader.SetMatrix4("view", ourMesh.Camera.GetViewMatrix());

        GL.BindVertexArray(ourMesh.VertexArrayObjectPointer);
        GL.DrawArraysInstanced(type, 0, ourMesh.size, Meshes.Count);
    }
    public void RenderWithIndices(PrimitiveType type = PrimitiveType.Triangles)
    {
        T ourMesh = Meshes[0];

        ourMesh.Shader.SetMatrix4("projection", ourMesh.Camera.GetProjectionMatrix());
        ourMesh.Shader.SetMatrix4("view", ourMesh.Camera.GetViewMatrix());

        GL.BindVertexArray(ourMesh.VertexArrayObjectPointer);
        GL.DrawElementsInstanced(type, ourMesh.indices.Length, DrawElementsType.UnsignedInt, 0, Meshes.Count); // render the mesh
    }
    #endregion
}
<br>}]]></description><link>api\rendering\meshclasses\instancedmesh.html</link><guid isPermaLink="false">API/Rendering/MeshClasses/InstancedMesh.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[InstancedMeshShaders]]></title><description><![CDATA[ 
 <br>using OpenTK.Graphics.OpenGL;<br>
using OpenTK.Mathematics;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Reflection;<br>
using System.Runtime.InteropServices;<br>
using System.Text;<br>
using System.Threading.Tasks;<br>namespace OpenglTestConsole.Classes.API.Rendering.MeshClasses<br>
{<br>
public partial class InstancedMesh where T : Mesh<br>
{<br>    public void SetMatrix4(Matrix4[] matrices, int loc, int offset = 1)
    {
        int vbo = GL.GenBuffer();

        GL.BindBuffer(BufferTarget.ArrayBuffer, vbo);
        GL.BufferData(BufferTarget.ArrayBuffer, matrices.Length * Marshal.SizeOf&lt;Matrix4&gt;(), matrices, BufferUsageHint.StaticDraw);

        foreach (T mesh in Meshes)
        {
            GL.BindVertexArray(mesh.VertexArrayObjectPointer); // bind the vertex array so that the buffer we made is used on this

            int matrixSize = Marshal.SizeOf&lt;Matrix4&gt;();

            // Set up each column (vec4) of the mat4 as a separate attribute
            for (int i = 0; i &lt; 4; i++)
            {
                int attribLocation = loc + i;
                GL.EnableVertexAttribArray(attribLocation);
                GL.VertexAttribPointer(attribLocation, 4, VertexAttribPointerType.Float, false, matrixSize, i * Vector4.SizeInBytes);
                GL.VertexAttribDivisor(attribLocation, offset);
            }
        }
    }

    public void SetVector4(Vector4[] vectors, int loc, int offset = 1)
    {
        int VBOPointer = GL.GenBuffer();

        // generate vertex buffer object
        GL.BindBuffer(BufferTarget.ArrayBuffer, VBOPointer); // bind buffer
        GL.BufferData(BufferTarget.ArrayBuffer, vectors.Length * Vector4.SizeInBytes, vectors, BufferUsageHint.StaticDraw); // put data in buffer

        foreach (T mesh in Meshes)
        {
            GL.BindVertexArray(mesh.VertexArrayObjectPointer); // bind the vertex array so that the buffer we made is used on this

            GL.EnableVertexAttribArray(loc); // enable loc 0

            GL.VertexAttribPointer(loc, 4, VertexAttribPointerType.Float, false, Vector4.SizeInBytes, 0); // bind the buffer to location 0

            GL.VertexAttribDivisor(loc, offset);
        }
    }


    public Y[] GetFieldValuesFromMeshes&lt;Y&gt;(string fieldOrPropertyName)
    { // is this dumb? probably, but i dont care
        return Meshes.Select(mesh =&gt;
        {
            var type = mesh.GetType();

            // Try to get a field first
            var field = type.GetField(fieldOrPropertyName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            if (field != null &amp;&amp; field.FieldType == typeof(Y))
                return (Y)field.GetValue(mesh)!;

            // Try to get a property if field not found
            var prop = type.GetProperty(fieldOrPropertyName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            if (prop != null &amp;&amp; prop.PropertyType == typeof(Y))
                return (Y)prop.GetValue(mesh)!;

            throw new Exception($"Field or property '{fieldOrPropertyName}' not found or not of type {typeof(Y).Name} in mesh.");
        }).ToArray()!;
    }

}
<br>}]]></description><link>api\rendering\meshclasses\instancedmeshshaders.html</link><guid isPermaLink="false">API/Rendering/MeshClasses/InstancedMeshShaders.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Mesh]]></title><description><![CDATA[<a class="tag" href="?query=tag:region" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#region</a> 
 <br>using OpenglTestConsole.Classes.API.Rendering.Geometries;<br>
using OpenglTestConsole.Classes.API.Rendering.Shaders;<br>namespace OpenglTestConsole.Classes.API.Rendering.MeshClasses<br>
{<br>
public partial class Mesh<br>
{<br>
<a href=".?query=tag:region" class="tag" target="_blank" rel="noopener nofollow">#region</a> Init<br>
private Camera Camera<br>
{<br>
get =&gt; Scene.Camera;<br>
}<br>    private Geometry3D _geometry;
    public Geometry3D Geometry { get =&gt; _geometry; set { _geometry = value; _geometry.Apply(this.BufferManager); } }
    public Material Material { get; set; }
    public Transform Transform { get; set; } = new Transform();
    public BufferManager BufferManager { get; }

    // caps to enable before rendering
    public List&lt;EnableCap&gt; CapsToEnable { get; set; } = new();

    // caps to disable before rendering
    public List&lt;EnableCap&gt; CapsToDisable { get; set; } = new();

    // render type
    public PrimitiveType type { get; set; } = PrimitiveType.Triangles;

    public int VertexArrayObjectPointer { get; private set; }

    public Mesh(Geometry3D geometry, Material material)
    {
        this._geometry = geometry;
        this.Material = material;

        VertexArrayObjectPointer = GL.GenVertexArray();
        BufferManager = new BufferManager(VertexArrayObjectPointer);
        this.Geometry.Apply(this.BufferManager);
    }

    #endregion


    #region Render

    public virtual void Render()
    { // deadass render that shit cuh
        // on it boss ima render that shit cuh

        Enalbes();


        Material.Shader.Use();

        Material.Apply();

        Material.Shader.UniformManager.SetMatrix4("projection", Camera.GetProjectionMatrix());

        Material.Shader.UniformManager.SetMatrix4("view", Camera.GetViewMatrix());

        Material.Shader.UniformManager.SetMatrix4("model", Transform.GetModelMatrix());


        GL.BindVertexArray(VertexArrayObjectPointer);
        if (Geometry.IndicesLength &lt; 3) // check if we are using indices
            GL.DrawArrays(type, 0, Geometry.VerticesLength);
        GL.DrawElements(type, Geometry.IndicesLength, DrawElementsType.UnsignedInt, 0);

        Disables();
    }

    private void Enalbes()
    {
        foreach (EnableCap cap in CapsToDisable)
            GL.Disable(cap);

        foreach (EnableCap cap in CapsToEnable)
            GL.Enable(cap);
    }

    private void Disables()
    {
        foreach (EnableCap cap in CapsToDisable)
            GL.Enable(cap);

        foreach (EnableCap cap in CapsToEnable)
            GL.Disable(cap);
    }

    #endregion
}
<br>}]]></description><link>api\rendering\meshclasses\mesh.html</link><guid isPermaLink="false">API/Rendering/MeshClasses/Mesh.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[ComputeShader]]></title><description><![CDATA[ 
 <br>using System.Numerics;<br>
using OpenglTestConsole.Classes.API.Misc;<br>namespace OpenglTestConsole.Classes.API.Rendering.Shaders.Compute<br>
{<br>
public class ComputeShader : IDisposable<br>
{ // <a rel="noopener nofollow" class="external-link" href="https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction" target="_blank">https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction</a><br>
public bool initalised = false;<br>
public string computeShaderPath;<br>
public int Handle;<br>
public ComputeShaderUnitManager UnitManager;<br>
public ShaderUniformManager UniformManager;<br>
private bool disposed = false;<br>
public Vector3 groupSize { get; private set; }<br>    public ComputeShader(string computeShaderPath)
    {
        this.computeShaderPath = computeShaderPath;
        UnitManager = new ComputeShaderUnitManager(Handle);
        UniformManager = new ShaderUniformManager(Handle);
    }

    public void Init()
    {
        Handle = GL.CreateProgram();

        int computeShaderPointer = HandleComputeShader(computeShaderPath);

        GL.AttachShader(Handle, computeShaderPointer);

        GL.LinkProgram(Handle);

        GL.GetProgram(Handle, GetProgramParameterName.LinkStatus, out int shaderLinkSuccess);

        if (shaderLinkSuccess == 0)
        {
            string errorLog = GL.GetProgramInfoLog(Handle);
            Logger.Log(
                $"An error occured while loading compute shader for {LogColors.BrightWhite(Handle)}!\nError log:\n{errorLog}",
                LogLevel.Error
            );
        }

        // get the group size
        int[] size = new int[3];
        GL.GetProgram(Handle, (GetProgramParameterName)All.ComputeWorkGroupSize, size);
        groupSize = new Vector3(size[0], size[1], size[2]);

        GL.DetachShader(Handle, computeShaderPointer);
        GL.DeleteShader(computeShaderPointer);

        initalised = true;
    }

    public int HandleComputeShader(string path)
    {
        string computeSource;

        try
        {
            computeSource = File.ReadAllText(path);
        }
        catch (Exception e)
        {
            Logger.Log(
                $"An error occured while reading compute shader {LogColors.BrightWhite(path)}!\nError log:\n{e}",
                LogLevel.Error
            );
            return -1;
        }

        int computeShaderPointer = GL.CreateShader(ShaderType.ComputeShader);

        GL.ShaderSource(computeShaderPointer, computeSource);

        GL.CompileShader(computeShaderPointer);

        GL.GetShader(
            computeShaderPointer,
            ShaderParameter.CompileStatus,
            out int shaderCompileSuccess
        );

        if (shaderCompileSuccess == 0)
        {
            string errorLog = GL.GetShaderInfoLog(computeShaderPointer);
            Logger.Log(
                $"An error occured while loading compute shader {LogColors.BrightWhite(path)}!\nError log:\n{errorLog}",
                LogLevel.Error
            );
        }

        return computeShaderPointer;
    }

    public void DispatchForSize(int x, int y, int z)
    {
        Dispatch((int)(x / groupSize.X), (int)(y / groupSize.Y), (int)(z / groupSize.Z));
    }

    public void Dispatch(int x, int y, int z)
    {
        Use();
        if (initalised == false)
        {
            Logger.Log(
                $"Shader with {LogColors.BrightWhite(Handle)} used without initalisation, initalising..",
                LogLevel.Warning
            );
            Init();
        }
        GL.DispatchCompute(x, y, z);
    }

    #region unimportants
    ~ComputeShader()
    {
        if (disposed == false)
            Logger.Log($"GPU Resource leak! Did you forget to call Dispose()?", LogLevel.Error);
    }

    public void Use()
    {
        if (initalised == false)
        {
            Logger.Log(
                $"Shader with {LogColors.BrightWhite(Handle)} used without initalisation, initalising..",
                LogLevel.Warning
            );
            Init();
        }
        GL.UseProgram(Handle);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            GL.DeleteProgram(Handle);
            Logger.Log(
                $"{LogColors.BrightYellow("Disposed")} compute shader {LogColors.BrightWhite(Handle)}",
                LogLevel.Detail
            );
            disposed = true;
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    #endregion
}
<br>}]]></description><link>api\rendering\shaders\compute\computeshader.html</link><guid isPermaLink="false">API/Rendering/Shaders/Compute/ComputeShader.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[ComputeShaderUnitManager]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Rendering.Shaders.Compute<br>
{<br>
public class ComputeShaderUnitManager<br>
{<br>
public struct ImageBinding<br>
{<br>
public int Unit;<br>
public int Texture;<br>
public TextureAccess Access;<br>
public SizedInternalFormat Format;<br>        public ImageBinding(
            int unit,
            int texture,
            TextureAccess access,
            SizedInternalFormat format
        )
        {
            Unit = unit;
            Texture = texture;
            Access = access;
            Format = format;
        }
    }

    private int Handle;
    private List&lt;ImageBinding&gt; imageBindings = new List&lt;ImageBinding&gt;();

    public ComputeShaderUnitManager(int handle)
    {
        Handle = handle;
    }

    public void SetImageTexture(
        int texture,
        int unit,
        TextureAccess access = TextureAccess.ReadWrite,
        SizedInternalFormat format = SizedInternalFormat.Rgba32f
    )
    {
        // Remove any existing binding on that unit to avoid duplicates
        imageBindings.RemoveAll(b =&gt; b.Unit == unit);

        imageBindings.Add(new ImageBinding(unit, texture, access, format));
    }

    public void ApplyTextures()
    {
        foreach (var binding in imageBindings)
        {
            GL.BindImageTexture(
                binding.Unit, // Image unit index, corresponds to 'binding = unit' in GLSL
                binding.Texture, // OpenGL texture handle
                0, // Mipmap level
                false, // Not layered
                0, // Layer index
                binding.Access, // WriteOnly, ReadOnly, or ReadWrite
                binding.Format // Must match texture's internal format
            );
        }
    }
}
<br>}]]></description><link>api\rendering\shaders\compute\computeshaderunitmanager.html</link><guid isPermaLink="false">API/Rendering/Shaders/Compute/ComputeShaderUnitManager.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Shader]]></title><description><![CDATA[ 
 <br>using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;<br>
using System.Threading.Tasks;<br>namespace OpenglTestConsole.Classes.API.Rendering.Shaders<br>
{<br>
public partial class Shader<br>
{<br>
public string geometryPath { get; set; } = "NULL";<br>
public Shader(string vertexPath, string fragmentPath, string geometryPath)<br>
{ this.vertexPath = vertexPath; this.fragmentPath = fragmentPath; this.geometryPath = geometryPath; }<br>
private void InitGeometry()<br>
{<br>
if (this.geometryPath == "NULL")<br>
return;<br>        int geomShaderPointer = HandleShader(geometryPath, ShaderType.GeometryShader);

        GL.AttachShader(Handle, geomShaderPointer);
    }
}
<br>}]]></description><link>api\rendering\shaders\geometry\shader.html</link><guid isPermaLink="false">API/Rendering/Shaders/Geometry/Shader.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Material]]></title><description><![CDATA[ 
 <br>namespace OpenglTestConsole.Classes.API.Rendering.Shaders<br>
{<br>
public abstract class Material<br>
{<br>
// ok the plan should be easy<br>
// so i have Mesh but i want to set each mesh to a specific material<br>
// i can do it in the constructor, but thats meh<br>
// so ill just use generalised types like Mesh extends material or w/e<br>
public Material() { }<br>    public Shader Shader { get; set; }

    public abstract void Apply();
}
<br>}]]></description><link>api\rendering\shaders\material.html</link><guid isPermaLink="false">API/Rendering/Shaders/Material.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Shader]]></title><description><![CDATA[<a class="tag" href="?query=tag:region" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#region</a> 
 <br>using OpenglTestConsole.Classes.API.Misc;<br>namespace OpenglTestConsole.Classes.API.Rendering.Shaders<br>
{<br>
public partial class Shader : IDisposable<br>
{<br>
<a href=".?query=tag:region" class="tag" target="_blank" rel="noopener nofollow">#region</a> Main Shader Functions<br>
public bool initalised = false;<br>
public string vertexPath;<br>
public string fragmentPath;<br>
public int Handle { get; set; }<br>
private bool disposed = false;<br>
public ShaderUniformManager UniformManager;<br>    public Shader(string vertexPath, string fragmentPath)
    { this.vertexPath = vertexPath; this.fragmentPath = fragmentPath; }

    public void Init()
    {
        Handle = GL.CreateProgram();

        this.UniformManager = new ShaderUniformManager(Handle);

        int vertShaderPointer = HandleShader(vertexPath, ShaderType.VertexShader);

        int fragShaderPointer = HandleShader(fragmentPath, ShaderType.FragmentShader);

        GL.AttachShader(Handle, vertShaderPointer);
        GL.AttachShader(Handle, fragShaderPointer);

        // init the geometry shader, if we have one
        InitGeometry();

        GL.LinkProgram(Handle);

        GL.GetProgram(Handle, GetProgramParameterName.LinkStatus, out int shaderLinkSuccess);

        if (shaderLinkSuccess == 0)
        {
            string errorLog = GL.GetProgramInfoLog(Handle);
            Logger.Log(
                $"An error occured while loading shaders for {LogColors.BrightWhite(Handle)}!\nError log:\n{errorLog}",
                LogLevel.Error
            );
        }

        GL.DetachShader(Handle, vertShaderPointer);
        GL.DetachShader(Handle, fragShaderPointer);
        GL.DeleteShader(vertShaderPointer);
        GL.DeleteShader(fragShaderPointer);

        initalised = true;
    }

    private int HandleShader(string path, ShaderType type)
    {
        string source;

        try
        {
            source = File.ReadAllText(path);
        }
        catch (Exception ex)
        {
            Logger.Log(
                $"An error occured while loading {LogColors.BrightWhite(path)} for {LogColors.BrightWhite(Handle)} for {LogColors.BrightWhite(type.ToString())}:\n{ex.ToString()}",
                LogLevel.Error
            );
            Logger.Log($"Exiting", LogLevel.Error);
            throw;
        }

        int shaderPointer = GL.CreateShader(type);

        GL.ShaderSource(shaderPointer, source);

        GL.CompileShader(shaderPointer);

        GL.GetShader(
            shaderPointer,
            ShaderParameter.CompileStatus,
            out int shaderSuccess
        );

        if (shaderSuccess == 0)
        {
            string errorLog = GL.GetShaderInfoLog(shaderPointer);
            Logger.Log(
                $"An error occured while loading shaders for {LogColors.BrightWhite(Handle)}!\nError log:\n{errorLog}",
                LogLevel.Error
            );
        }

        Logger.Log(
            $"Loaded {LogColors.White(type)} for {LogColors.BrightWhite(Handle)} : {LogColors.BrightWhite(path)}",
            LogLevel.Detail
        );

        return shaderPointer;
    }

    ~Shader()
    {
        if (disposed == false)
        {
            Logger.Log(
                $"GPU Resource leak for shader! Did you forget to call Dispose()?",
                LogLevel.Error
            );
        }
    }

    public void Use()
    {
        if (initalised == false)
        {
            Logger.Log(
                $"Shader with {LogColors.BrightWhite(Handle)} used without initalisation, initalising..",
                LogLevel.Warning
            );
            Init();
        }
        GL.UseProgram(Handle);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            GL.DeleteProgram(Handle);
            Logger.Log(
                $"{LogColors.BrightYellow("Disposed")} shader {LogColors.BrightWhite(Handle)}",
                LogLevel.Detail
            );
            disposed = true;
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    #endregion
}
<br>}]]></description><link>api\rendering\shaders\shader.html</link><guid isPermaLink="false">API/Rendering/Shaders/Shader.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[ShaderUniformManager]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Textures;<br>
using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering.Shaders<br>
{<br>
public class ShaderUniformManager<br>
{<br>
private int Handle;<br>    public ShaderUniformManager(int handle)
    {
        Handle = handle;
    }

    #region Uniform Functions
    // cache uniforms so we dont run *expensive* get uniform location a shit ton
    private Dictionary&lt;string, int&gt; uniformCache = new Dictionary&lt;string, int&gt;();

    public void SetMatrix4(string name, Matrix4 matrix)
    {
        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            GL.UniformMatrix4(loc, true, ref matrix);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetMatrix4(name, matrix);
        }
    }

    public void SetVector4(string name, Vector4 vector)
    {
        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            GL.Uniform4(loc, vector);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetVector4(name, vector);
        }
    }

    public void SetVector3(string name, Vector3 vector)
    {
        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            GL.Uniform3(loc, vector);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetVector3(name, vector);
        }
    }

    public void SetVector2(string name, Vector2 vector)
    {
        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            GL.Uniform2(loc, vector);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetVector2(name, vector);
        }
    }

    public void SetFloat(string name, float value)
    {
        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            GL.Uniform1(loc, value);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetFloat(name, value);
        }
    }

    public void SetInt(string name, int value)
    {
        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            GL.Uniform1(loc, value);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetInt(name, value);
        }
    }

    public void SetColor(string name, Color4 color)
    {
        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            GL.Uniform4(loc, color);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetColor(name, color);
        }
    }

    public void SetTexture(string name, Texture tex, OpenTK.Graphics.OpenGL.TextureUnit unit)
    {
        tex.Activate(unit);
        tex.Bind();

        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            int unitint = (int)unit - (int)TextureUnit.Texture0;
            GL.Uniform1(loc, unitint);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetTexture(name, tex, unit);
        }
    }

    public void SetCubemap(string name, Cubemap cubemap, OpenTK.Graphics.OpenGL.TextureUnit unit)
    {

        cubemap.Activate(unit);
        cubemap.Bind();

        if (uniformCache.ContainsKey(name))
        {
            uniformCache.TryGetValue(name, out int loc);
            int unitint = (int)unit - (int)TextureUnit.Texture0;
            GL.Uniform1(loc, unitint);
        }
        else
        {
            uniformCache.Add(name, GL.GetUniformLocation(Handle, name));
            SetCubemap(name, cubemap, unit);
        }
    }

    #endregion
}
<br>}]]></description><link>api\rendering\shaders\shaderuniformmanager.html</link><guid isPermaLink="false">API/Rendering/Shaders/ShaderUniformManager.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Cubemap]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;<br>
using System;<br>
using System.Collections.Generic;<br>
using System.IO;<br>
using System.Linq;<br>
using System.Security.AccessControl;<br>
using System.Text;<br>
using System.Threading.Tasks;<br>namespace OpenglTestConsole.Classes.API.Rendering.Textures<br>
{<br>
public class Cubemap : IDisposable<br>
{<br>
public int Handle { get; set; }<br>
public bool initalised = false;<br>
private bool _disposed = false;<br>
public bool disposed<br>
{<br>
get<br>
{ // İF all of the textures are disposed and this cubemap is disposed, then return disposed<br>
return textures.All(tex =&gt; tex.disposed) &amp;&amp; this._disposed == true;<br>
}<br>
private set =&gt; _disposed = value;<br>
}<br>    #region sides
    public Texture Right { get; init; }
    public Texture Left { get; init; }
    public Texture Top { get; init; }
    public Texture Bottom { get; init; }
    public Texture Back { get; init; }
    public Texture Front { get; init; }
    public Texture[] textures { get =&gt; [Right, Left, Top, Bottom, Front, Back]; }
    #endregion

    public Cubemap(Texture[] inTextures)
    {
        #pragma warning disable format
        Right   =   inTextures[0];      Left    =     inTextures[1];
        Top     =   inTextures[2];      Bottom  =     inTextures[3];
        Back    =   inTextures[4];      Front   =     inTextures[5];      
        #pragma warning restore format
    }

    public void Init()
    {
        Handle = GL.GenTexture();
        GL.BindTexture(TextureTarget.Texture2D, Handle);


        if (this.textures.Any(tex =&gt; tex.initalised == true))
        { // check if any of the textures are initalized, we need them to not be initalized
            string initalisedTextures = "";
            foreach (Texture tex in textures)
            {
                if (tex.initalised)
                {
                    initalisedTextures += $"{LogColors.BrightWhite(tex.Handle)}, ";
                }
            }

            Logger.Log($"Cubemap {LogColors.BrightWhite(Handle)} recieved initalised Texture(s): {initalisedTextures}", LogLevel.Error);
        }

        for (int i = 0; i &lt; textures.Length; i++)
        {
            Texture tex = textures[i]; // set the cube map type of the texture
            tex.Target = TextureTarget.TextureCubeMapPositiveX + i;
            tex.flipped = false;
            tex.Init(); // init it while we are binded to the cubemap, which will attatch the texture to the cubemap
        }

        /* 
            https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/6.2.cubemaps_environment_mapping/cubemaps_environment_mapping.cpp
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); // x clamping
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // y clamping
            glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); // z clamping
         */

        GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Linear);
        GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureMagFilter, (int)TextureMinFilter.Linear);

        GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapS, (int)TextureWrapMode.ClampToEdge);
        GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapT, (int)TextureWrapMode.ClampToEdge);
        GL.TexParameter(TextureTarget.TextureCubeMap, TextureParameterName.TextureWrapR, (int)TextureWrapMode.ClampToEdge);
        Logger.Log(
            $"Initalized Cubemap {LogColors.BrightWhite(Handle)}",
            LogLevel.Detail
        );

        this.initalised = true;
    }

    private void Check()
    {
        if (initalised)
            return;
        Logger.Log($"Cubemap {Handle} used without initalisation", LogLevel.Error);
    }
    public void Bind()
    {
        Check();
        GL.BindTexture(TextureTarget.Texture2D, Handle);
    }
    public void Activate(TextureUnit unit)
    {
        Check();
        GL.ActiveTexture(unit);
    }

    #region disposal
    ~Cubemap()
    {
        if (disposed == false)
            Logger.Log(
                $"GPU Resource leak for cubemap! Did you forget to call Dispose()?",
                LogLevel.Error
            );
    }

    protected virtual void Dispose(bool disposing, bool log = true)
    {
        if (!disposed)
        {
            if (log)
                Logger.Log(
                $"{LogColors.BrightYellow("Disposed")} Cubemap {LogColors.BrightWhite(Handle)}",
                LogLevel.Detail
            );
            foreach (var texture in textures)
                texture.Dispose();
            GL.DeleteTexture(Handle);
            Handle = 0;
            disposed = true;
        }
    }
    public bool logDisposal = true;

    public void Dispose()
    {
        Dispose(true, logDisposal);
        GC.SuppressFinalize(this);
    }
    #endregion
}
<br>}]]></description><link>api\rendering\textures\cubemap.html</link><guid isPermaLink="false">API/Rendering/Textures/Cubemap.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[FBO]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.Implementations.Classes;<br>namespace OpenglTestConsole.Classes.API.Rendering.Textures<br>
{<br>
public class FBO<br>
{<br>
public int Handle { get; set; }<br>
public FBO()<br>
{<br>    }
    public void Init()
    {
        // you just HAD to do shit with pointers
        unsafe
        {
            uint temp = 0; // create the fbo
            GL.CreateFramebuffers(1, &amp;temp);
            Handle = (int)temp;
        }

        // bind the fbo so we are working on it
        GL.BindFramebuffer(FramebufferTarget.Framebuffer, Handle);
        int x = Settings.Resolution.X;
        int y = Settings.Resolution.Y;

        // create texture thats the same size as the window (not required)
        // TODO: change this when we get settings for window size or w/e
        Texture colorTexture = Texture.LoadFromSize(x, y);

        GL.FramebufferTexture2D( // attatch the texture
            FramebufferTarget.Framebuffer, // the frame buffer will write to this texture
            FramebufferAttachment.ColorAttachment0, // attatchment type
            TextureTarget.ProxyTexture2D, // texture type
            colorTexture.Handle,
            0 // mipmap level
         );

        // create the depth and stencil texture
        Texture depthAndStencilTexture = Texture.LoadFromSize(
            x,
            y,
            target: TextureTarget.Texture2D,
            pixelInternalFormat: PixelInternalFormat.Depth24Stencil8,
            pixelFormat: PixelFormat.DepthStencil,
            type: PixelType.UnsignedInt248
         );

        // bind the depth and stencil texture
        GL.FramebufferTexture2D( // same as the above texture 2d
            FramebufferTarget.Framebuffer,
            FramebufferAttachment.DepthStencilAttachment,
            TextureTarget.Texture2D,
            depthAndStencilTexture.Handle,
            0
         );

        if (GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer) != FramebufferErrorCode.FramebufferComplete)
        {
            Misc.Logger.Log(
               $"An error occured while creating frame buffer for {Misc.LogColors.BrightWhite(Handle)} :\n" +
               $"{GL.CheckFramebufferStatus(FramebufferTarget.Framebuffer).ToString()}",
               Misc.LogLevel.Error
            );
        }
        else
        {
            Misc.Logger.Log(
                $"Loaded FBO {Misc.LogColors.BrightWhite(Handle)}:\n" +
                $"Color Texture: {Misc.LogColors.BrightWhite(colorTexture.Handle)}" +
                $"Depth &amp; Stencil: {Misc.LogColors.BrightWhite(depthAndStencilTexture.Handle)}",
               Misc.LogLevel.Detail
            );
        }
        // execute victory dance
    }


}
<br>}]]></description><link>api\rendering\textures\fbo.html</link><guid isPermaLink="false">API/Rendering/Textures/FBO.md</guid><pubDate>Fri, 30 May 2025 19:57:47 GMT</pubDate></item><item><title><![CDATA[Texture]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Misc;<br>
using OpenTK.Audio.OpenAL;<br>
using OpenTK.Mathematics;<br>
using SixLabors.ImageSharp;<br>
using SixLabors.ImageSharp.PixelFormats;<br>
using SixLabors.ImageSharp.Processing;<br>
using System.IO;<br>
using static OpenglTestConsole.Generated.Paths.ResourcePaths.Materials;<br>namespace OpenglTestConsole.Classes.API.Rendering.Textures<br>
{<br>
public class Texture : IDisposable<br>
{<br>
public int Handle { get; set; }<br>
public bool initalised = false;<br>
public int width, height;<br>
public bool disposed { get; private set; } = false;<br>    #region creation
    public TextureTarget Target { get; set; }
    public PixelInternalFormat PixelInternalFormat { get; set; }
    public PixelFormat PixelFormat { get; set; }
    public PixelType PixelType { get; set; }
    public TextureWrapMode TextureSWrapMode { get; set; }
    public TextureWrapMode TextureTWrapMode { get; set; }
    private byte[] bytes { get; set; }
    public bool flipped = true;
    public Texture() { }

    public static Texture LoadFromFile(
        string path,
        TextureTarget target = TextureTarget.Texture2D,
        PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba,
        PixelFormat pixelFormat = PixelFormat.Rgba,
        PixelType type = PixelType.UnsignedByte,
        TextureWrapMode textureSWrapMode = TextureWrapMode.Repeat,
        TextureWrapMode textureTWrapMode = TextureWrapMode.Repeat
    ) =&gt; LoadFromTextureBytes(
             File.ReadAllBytes(path),
             target: target,
             pixelInternalFormat: pixelInternalFormat,
             pixelFormat: pixelFormat,
             type: type,
             textureSWrapMode: textureSWrapMode,
             textureTWrapMode: textureTWrapMode
        );


    public static Texture LoadFromTextureBytes(
        byte[] bytes,
        TextureTarget target = TextureTarget.Texture2D,
        PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba,
        PixelFormat pixelFormat = PixelFormat.Rgba,
        PixelType type = PixelType.UnsignedByte,
        TextureWrapMode textureSWrapMode = TextureWrapMode.Repeat,
        TextureWrapMode textureTWrapMode = TextureWrapMode.Repeat
    )
    {

        Image&lt;Rgba32&gt; image;

        try
        {
            image = Image.Load&lt;Rgba32&gt;(bytes);
        }
        catch (Exception ex)
        {
            Logger.Log(
                $"An error occured while loading {LogColors.BrightWhite("LoadFromTextureBytes")}:\n{ex.ToString()}",
                LogLevel.Error
            );
            // this aint working properly fix it sometime ig
            Logger.Log($"Using default texture...", LogLevel.Warning);
            image = Image.Load&lt;Rgba32&gt;(File.ReadAllBytes("Resources/Textures/PlaceHolder.png"));
        }


        byte[] pixelDataArray = new byte[image.Width * image.Height * 4];
        image.CopyPixelDataTo(pixelDataArray);

        Texture texture = LoadFromBytes(
            bytes: pixelDataArray,
            width: image.Width,
            height: image.Height,
            target: target,
            pixelInternalFormat: pixelInternalFormat,
            pixelFormat: pixelFormat,
            type: type,
            textureSWrapMode: textureSWrapMode,
            textureTWrapMode: textureTWrapMode
        );
        image.Dispose();

        return texture;
    }

    public static Texture LoadFromBytes(
        byte[] bytes,
        int width,
        int height,
        TextureTarget target = TextureTarget.Texture2D,
        PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba,
        PixelFormat pixelFormat = PixelFormat.Rgba,
        PixelType type = PixelType.UnsignedByte,
        TextureWrapMode textureSWrapMode = TextureWrapMode.Repeat,
        TextureWrapMode textureTWrapMode = TextureWrapMode.Repeat
    )
    {
        Texture texture = new();
        texture.bytes = bytes;
        texture.width = width;
        texture.height = height;
        texture.Target = target;
        texture.PixelInternalFormat = pixelInternalFormat;
        texture.PixelFormat = pixelFormat;
        texture.PixelType = type;
        texture.TextureSWrapMode = textureSWrapMode;
        texture.TextureTWrapMode = textureTWrapMode;

        return texture;
    }

    public void Init()
    {
        this.Handle = GL.GenTexture();

        if (flipped)
        {
            var image = Image.LoadPixelData&lt;Rgba32&gt;(
                data: bytes,
                width: width,
                height: height
            );
            image.Mutate(s =&gt; s.Flip(FlipMode.Vertical));
            image.CopyPixelDataTo(bytes);
            image.Dispose();
        }

        if (this.Handle == 0)
            Logger.Log(
                $"Failed to generate texture for LoadFromBytes",
            LogLevel.Error
            );

        GL.BindTexture(TextureTarget.Texture2D, this.Handle);

        GL.TexParameter(
            TextureTarget.Texture2D,
            TextureParameterName.TextureWrapS,
            (int)TextureSWrapMode
        );
        GL.TexParameter(
            TextureTarget.Texture2D,
            TextureParameterName.TextureWrapT,
            (int)TextureTWrapMode
        );

        GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureBaseLevel, 0);
        GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMaxLevel, 0);
        GL.TexImage2D(
            this.Target,
            0,
            this.PixelInternalFormat,
            width,
            height,
            0,
            this.PixelFormat,
            this.PixelType,
            bytes
        );
        this.initalised = true;
        this.bytes = [];
        Logger.Log(
            $"Initalized texture {LogColors.BrightWhite(this.Handle)}",
            LogLevel.Detail
        );
    }

    public static Texture LoadFromSize( // shouldnt need an init
        int width,
        int height,
        TextureTarget target = TextureTarget.Texture2D,
        PixelInternalFormat pixelInternalFormat = PixelInternalFormat.Rgba,
        PixelFormat pixelFormat = PixelFormat.Rgba,
        PixelType type = PixelType.UnsignedByte
    )
    {
        Texture texture = new Texture();
        texture.Handle = GL.GenTexture();
        texture.width = width;
        texture.height = height;
        GL.BindTexture(TextureTarget.Texture2D, texture.Handle);
        GL.TexParameter(
            TextureTarget.Texture2D,
            TextureParameterName.TextureWrapS,
            (int)TextureWrapMode.Repeat
        );
        GL.TexParameter(
            TextureTarget.Texture2D,
            TextureParameterName.TextureWrapT,
            (int)TextureWrapMode.Repeat
        );
        GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureBaseLevel, 0);
        GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMaxLevel, 0);
        GL.TexImage2D(
            target,
            0,
            pixelInternalFormat,
            width,
            height,
            0,
            pixelFormat,
            type,
            nint.Zero
        );
        texture.initalised = true;
        Logger.Log(
            $"Initalized empty texture {LogColors.BrightWhite(texture.Handle)}: {LogColors.BrightWhite(width)}x{LogColors.BrightWhite(height)}",
            LogLevel.Detail
        );
        return texture;
    }
    #endregion

    #region opengl functions
    private void Check()
    {
        if (initalised)
            return;
        Logger.Log($"Texture {Handle} used without initalisation", LogLevel.Error);
    }

    public void Bind()
    {
        Check();
        GL.BindTexture(TextureTarget.Texture2D, Handle);
    }

    public void Activate(TextureUnit unit)
    {
        Check();
        GL.ActiveTexture(unit);
    }
    #endregion

    public byte[] GetBytes()
    {
        byte[] output = new byte[
            4 *
            width *
            height
        ];

        unsafe
        {
            fixed (byte* outputPtr = output)
            {
                Bind();
                GL.GetTexImage(
                    TextureTarget.Texture2D,
                    0,
                    PixelFormat.Rgba,
                    PixelType.UnsignedByte,
                    (nint)outputPtr
                );
            }
        }

        return output;
    }

    public void SaveToFile(string filePath)
    {
        Vector2i size = new(width, height);
        var image = Image.LoadPixelData&lt;Rgba32&gt;(GetBytes(), size.X, size.Y);
        image.Mutate(s =&gt; s.Flip(FlipMode.Vertical));
        if (filePath.Contains(".jpg") || filePath.Contains(".jpeg"))
            image.SaveAsJpeg(filePath);
        else
            image.SaveAsPng(filePath);
        Logger.Log(
            $"Saved Texture with {LogColors.BrightWhite(Handle)} as {LogColors.BrightWhite(filePath)}",
            LogLevel.Detail
        );
    }

    #region disposal
    ~Texture()
    {
        if (disposed == false)
            Logger.Log(
                $"GPU Resource leak for texture! Did you forget to call Dispose()?",
                LogLevel.Error
            );
    }

    protected virtual void Dispose(bool disposing, bool log = true)
    {
        if (!disposed)
        {
            if (log)
                Logger.Log(
                $"{LogColors.BrightYellow("Disposed")} Texture {LogColors.BrightWhite(Handle)}",
                LogLevel.Detail
            );

            GL.DeleteTexture(Handle);
            Handle = 0;
            disposed = true;
        }
    }
    public bool logDisposal = true;

    public void Dispose()
    {
        Dispose(true, logDisposal);
        GC.SuppressFinalize(this);
    }
    #endregion
}
<br>}]]></description><link>api\rendering\textures\texture.html</link><guid isPermaLink="false">API/Rendering/Textures/Texture.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Camera]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.Implementations.Classes;<br>
using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering<br>
{<br>
public class Camera<br>
{<br>
public Vector3 Position = Vector3.Zero;<br>
public int screenWidth;<br>
public int screenHeight;<br>
public float depthNear = 0.1f;<br>
public float depthFar = 400f;<br>
private float _pitch;<br>
private float _yaw = -MathHelper.PiOver2;<br>
private Vector3 _front = -Vector3.UnitZ;<br>
private Vector3 _up = Vector3.UnitY;<br>
private Vector3 _right = Vector3.UnitX;<br>    public float Pitch
    {
        get =&gt; MathHelper.RadiansToDegrees(_pitch);
        set
        {
            // We clamp the pitch value between -89 and 89 to prevent the camera from going upside down, and a bunch
            // of weird "bugs" when you are using euler angles for rotation.
            // If you want to read more about this you can try researching a topic called gimbal lock
            var angle = MathHelper.Clamp(value, -89f, 89f);
            _pitch = MathHelper.DegreesToRadians(angle);
            UpdateVectors();
        }
    }
    public float Yaw
    {
        get =&gt; MathHelper.RadiansToDegrees(_yaw);
        set
        {
            _yaw = MathHelper.DegreesToRadians(value);
            UpdateVectors();
        }
    }

    public Camera(int screenWidth, int screenHeight)
    {
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
    }

    public Matrix4 GetViewMatrix()
    {
        return Matrix4.LookAt(Position, Position + _front, _up);
    }

    public Matrix4 GetProjectionMatrix()
    {
        return Matrix4.CreatePerspectiveFieldOfView(
            Settings.FOVRadian,
            screenWidth / screenHeight,
            //1.333f, // 1.333 looks less trippy so
            //1f,
            depthNear,
            depthFar
        );
    }

    // This function is going to update the direction vertices using some of the math learned in the web tutorials.
    private void UpdateVectors()
    {
        // First, the front matrix is calculated using some basic trigonometry.
        _front.X = MathF.Cos(_pitch) * MathF.Cos(_yaw);
        _front.Y = MathF.Sin(_pitch);
        _front.Z = MathF.Cos(_pitch) * MathF.Sin(_yaw);

        // We need to make sure the vectors are all normalized, as otherwise we would get some funky results.
        _front = Vector3.Normalize(_front);

        // Calculate both the right and the up vector using cross product.
        // Note that we are calculating the right from the global up; this behaviour might
        // not be what you need for all cameras so keep this in mind if you do not want a FPS camera.
        _right = Vector3.Normalize(Vector3.Cross(_front, Vector3.UnitY));
        _up = Vector3.Normalize(Vector3.Cross(_right, _front));
    }
}
<br>}]]></description><link>api\rendering\camera.html</link><guid isPermaLink="false">API/Rendering/Camera.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Light]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering<br>
{<br>
public class Light<br>
{<br>
public Vector3 Position = Vector3.Zero;<br>
public Vector3 Color = Vector3.Zero;<br>    public Light(Vector3 location, Vector3 color)
    {
        Position = location;
        Color = color;
    }

    public Vector3 Specular
    {
        get =&gt; Color;
    }
    public Vector3 Diffuse
    {
        get =&gt; Color * 0.7f;
    }
    public Vector3 Ambient
    {
        get =&gt; Color * 0.4f;
    }
}
<br>}]]></description><link>api\rendering\light.html</link><guid isPermaLink="false">API/Rendering/Light.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[RenderScript]]></title><description><![CDATA[ 
 <br>using System.Diagnostics;<br>
using OpenTK.Windowing.Common;<br>namespace OpenglTestConsole.Classes.API.Rendering<br>
{<br>
public abstract class RenderScript<br>
{<br>
public FrameEventArgs args;<br>
public Camera Camera { get; set; }<br>
public Stopwatch Timer { get; set; }<br>
public Scene Scene { get; set; }<br>
public abstract void Init();<br>
public abstract void Advance();<br>    public virtual void OnResourceRefresh() { }
    public virtual void BeforeRender() { }
    public virtual void AfterRender() { }
}
<br>}]]></description><link>api\rendering\renderscript.html</link><guid isPermaLink="false">API/Rendering/RenderScript.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Transform]]></title><description><![CDATA[ 
 <br>using OpenTK.Mathematics;<br>namespace OpenglTestConsole.Classes.API.Rendering<br>
{<br>
public class Transform<br>
{<br>
public Vector3 Position = Vector3.Zero;<br>
private Vector3 _rotation = Vector3.Zero;<br>
public Vector3 Rotation = Vector3.Zero;<br>
private Matrix4 cacheMatrix = Matrix4.Identity;<br>    public Transform()
    {
        UpdateMatrix();
    }

    public void UpdateMatrix()
    {
        _rotation = Rotation * new Vector3((float)(Math.PI / 180f));
        Matrix4 rotation =
            Matrix4.CreateRotationX(_rotation.Y)
            * Matrix4.CreateRotationY(_rotation.Z)
            * Matrix4.CreateRotationZ(_rotation.X);

        this.cacheMatrix =
            Matrix4.CreateScale(Scale)
            * rotation
            * Matrix4.CreateTranslation(Position)
            * Matrix4.Identity;
    }

    public Vector3 Scale = Vector3.One;

    public Matrix4 GetModelMatrix()
    {
        // DONE: you only need to reinitilise rotation when the rotation is updated, make this more efficent
        // you dont even need to remake the whole thing really, cache this thing cuh!

        return cacheMatrix;
    }

    public void Reset()
    {
        Position = Vector3.Zero;
        Rotation = Vector3.Zero;
        Scale = Vector3.One;
        UpdateMatrix();
    }
}
<br>}]]></description><link>api\rendering\transform.html</link><guid isPermaLink="false">API/Rendering/Transform.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[EveryFrameScript]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering;<br>
using OpenTK.Windowing.Common;<br>
using OpenTK.Windowing.GraphicsLibraryFramework;<br>namespace OpenglTestConsole.Classes.API<br>
{<br>
public abstract class EveryFrameScript<br>
{<br>
public MouseState MouseState { get; set; }<br>
public KeyboardState KeyboardState { get; set; }<br>
public Camera Camera { get; set; }<br>
public Main MainInstance { get; set; }<br>
public FrameEventArgs args { get; set; }<br>
public abstract void Init();<br>
public abstract void Advance();<br>    public virtual void OnResourceRefresh() { }
}
<br>}]]></description><link>api\everyframescript.html</link><guid isPermaLink="false">API/EveryFrameScript.md</guid><pubDate>Mon, 26 May 2025 13:57:31 GMT</pubDate></item><item><title><![CDATA[ResourceController]]></title><description><![CDATA[ 
 <br>using System.Reflection;<br>
using OpenglTestConsole.Classes.API.JSON;<br>
using OpenglTestConsole.Classes.API.Misc;<br>
using OpenglTestConsole.Classes.API.Rendering.Shaders;<br>
using OpenglTestConsole.Classes.API.Rendering.Shaders.Compute;<br>
using OpenglTestConsole.Classes.API.Rendering.Textures;<br>
using OpenglTestConsole.Generated.Paths;<br>namespace OpenglTestConsole.Classes.API<br>
{<br>
public class ResourceController<br>
{<br>
public static void Refresh()<br>
{<br>
foreach (KeyValuePair&lt;string, Shader&gt; item in Resources.Shaders)<br>
item.Value.Dispose();<br>        foreach (KeyValuePair&lt;string, ComputeShader&gt; item in Resources.CompShaders)
            item.Value.Dispose();

        foreach (KeyValuePair&lt;string, Texture&gt; item in Resources.Textures)
            item.Value.Dispose();

        Resources.Shaders.Clear();
        Resources.Textures.Clear();
        Resources.CompShaders.Clear();
        Resources.Fonts.Clear();

        Init();
    }

    public static void Init()
    {
        AddTextures();
        AddShaders();
        // interesting intellisense suggestion aint it!
        // however materials are pmuch shaders, so
        // can do some texture pbr stuff ig
        // AddMaterials();
        AddComputeShaders();
        AddFonts();
        AddCubemaps();
    }
    #region textures
    private static void AddTextures()
    {
        foreach (FieldInfo texture in typeof(ResourcePaths.Resources.Textures).GetFields())
            AddTexture(texture);
    }

    private static void AddTexture(FieldInfo texture)
    {
        // get the constant path value from the class
        string texturePath = (string)texture.GetValue(null)!;
        // add the texture to the resources
        Resources.Textures.Add(texturePath, Texture.LoadFromFile(texturePath));
        Logger.Log($"Loading {LogColors.Green("Texture")} {LogColors.BrightWhite(texturePath)}", LogLevel.Detail);
        Resources.Textures[texturePath].Init();
    }
    #endregion
    #region compute shaders
    private static void AddComputeShaders()
    {
        foreach (Type compShader in typeof(ResourcePaths.ComputeShaders).GetNestedTypes())
        {
            AddComputeShader(compShader);
        }
    }

    private static void AddComputeShader(Type type)
    {
        string shaderName = (string)type!.GetField("Name")!.GetValue(null)!;
        string compute = (string)type!.GetField("Compute")!.GetValue(null)!;
        // add the shader to the resources
        Resources.CompShaders.Add(shaderName, new(compute));
        Resources.CompShaders[shaderName].Init();
    }
    #endregion
    #region shaders
    private static void AddShaders()
    {
        foreach (var shader in typeof(ResourcePaths.Materials).GetNestedTypes())
            AddShader(shader);
    }

    private static void AddShader(Type type)
    {
        // get the shader information
        string shaderName = (string)type!.GetField("Name")!.GetValue(null)!;
        string fragment = (string)type!.GetField("Fragment")!.GetValue(null)!;
        string vertex = (string)type!.GetField("Vertex")!.GetValue(null)!;

        string? geometry = (string?)type?.GetField("Geometry")?.GetValue(null);
        if (string.IsNullOrEmpty(geometry))
            Resources.Shaders.Add(shaderName, new(vertex, fragment));
        else
            Resources.Shaders.Add(shaderName, new(vertex, fragment, geometry));
        // add the shader to the resources
        Logger.Log($"Loading {LogColors.Green("Shader")} {LogColors.BrightWhite(shaderName)}", LogLevel.Detail);

        Resources.Shaders[shaderName].Init();
    }
    #endregion
    #region fonts
    private static void AddFonts()
    {
        foreach (var font in typeof(ResourcePaths.Fonts).GetNestedTypes())
        {
            AddFont(font);
        }
    }

    private static void AddFont(Type type)
    {
        string fontName = (string)type!.GetField("Name")!.GetValue(null)!;
        string fontJSONPath = (string)type!.GetField("JSON")!.GetValue(null)!;
        FieldInfo fontPNGField = type.GetField("PNG")!;
        Resources.Fonts.Add(fontName, MCSDFJSON.GetFontJson(fontJSONPath)!);

        AddTexture(fontPNGField);
    }
    #endregion
    #region cubemaps
    private static void AddCubemaps()
    {
        foreach (var map in typeof(ResourcePaths.Cubemaps).GetNestedTypes())
            AddCubemap(map);
    }
    private static void AddCubemap(Type type)
    {
        // get the cubemap information
        string cubemapName = (string)type!.GetField("Name")!.GetValue(null)!;

        string rightSide = (string)type!.GetField("Right")!.GetValue(null)!;
        string leftSide = (string)type!.GetField("Left")!.GetValue(null)!;
        string topSide = (string)type!.GetField("Top")!.GetValue(null)!;
        string bottomSide = (string)type!.GetField("Bottom")!.GetValue(null)!;
        string backSide = (string)type!.GetField("Back")!.GetValue(null)!;
        string frontSide = (string)type!.GetField("Front")!.GetValue(null)!;


        Texture[] textures =
            [
                Texture.LoadFromFile(rightSide),
                Texture.LoadFromFile(leftSide),
                Texture.LoadFromFile(topSide),
                Texture.LoadFromFile(bottomSide),
                Texture.LoadFromFile(backSide),
                Texture.LoadFromFile(frontSide),
            ];


        Logger.Log($"Loading {LogColors.Green("Cubemap")} {LogColors.BrightWhite(cubemapName)}", LogLevel.Detail);

        Resources.Cubemaps.Add(cubemapName, new(textures));
        Resources.Cubemaps[cubemapName].Init();
    }
    #endregion
}
<br>}]]></description><link>api\resourcecontroller.html</link><guid isPermaLink="false">API/ResourceController.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Resources]]></title><description><![CDATA[ 
 <br>using OpenglTestConsole.Classes.API.Rendering.Shaders;<br>
using OpenglTestConsole.Classes.API.Rendering.Shaders.Compute;<br>
using OpenglTestConsole.Classes.API.Rendering.Textures;<br>
using static OpenglTestConsole.Classes.API.JSON.MCSDFJSON;<br>namespace OpenglTestConsole.Classes.API<br>
{<br>
public static class Resources<br>
{<br>
public static Dictionary&lt;string, Texture&gt; Textures { get; set; } = new();<br>
public static Dictionary&lt;string, Shader&gt; Shaders { get; set; } = new();<br>
public static Dictionary&lt;string, ComputeShader&gt; CompShaders { get; set; } = new();<br>
public static Dictionary&lt;string, FontJson&gt; Fonts { get; set; } = new();<br>
public static Dictionary&lt;string, Cubemap&gt; Cubemaps { get; set; } = new();<br>
}<br>
}]]></description><link>api\resources.html</link><guid isPermaLink="false">API/Resources.md</guid><pubDate>Fri, 30 May 2025 19:59:13 GMT</pubDate></item><item><title><![CDATA[Scene]]></title><description><![CDATA[ 
 <br>using System.Diagnostics;<br>
using OpenglTestConsole.Classes.API.Rendering;<br>
using OpenglTestConsole.Classes.API.Rendering.MeshClasses;<br>
using OpenTK.Windowing.Common;<br>namespace OpenglTestConsole.Classes.API<br>
{<br>
public class Scene<br>
{ // i am going for a threejs like api<br>
public static List Lights { get; set; } = new();<br>
public static Camera Camera { get; set; } = new Camera(800, 600);<br>
public Stopwatch Timer = new Stopwatch();<br>
private List&lt;List&gt; renderList = [];<br>    public void Add(Mesh mesh) =&gt; renderList.Add([mesh]);

    public void Add(List&lt;Mesh&gt; mesh) =&gt; renderList.Add(mesh);

    public Scene()
    {
        Timer = new Stopwatch();
        Timer.Start();
    }

    public void Init(List&lt;RenderScript&gt; renderScripts, Camera? camera = null)
    {
        if (camera != null)
            Camera = camera;

        foreach (RenderScript script in renderScripts)
        {
            script.Camera = Camera;
            script.Timer = Timer;
            script.Scene = this;

            script.Init();
        }
    }

    public void Render(
        List&lt;RenderScript&gt; renderScripts,
        FrameEventArgs args,
        Camera? camera = null
    )
    {
        if (camera != null)
            Camera = camera;

        foreach (RenderScript script in renderScripts)
        {
            // advance the render scripts
            script.args = args;
            script.Camera = Camera;
            script.Timer = Timer;
            script.Scene = this;

            script.Advance();
        }

        // before render
        foreach (RenderScript script in renderScripts)
        {
            // advance the render scripts
            script.args = args;
            script.Camera = Camera;
            script.Timer = Timer;
            script.Scene = this;

            script.BeforeRender();
        }

        // render the meshes added by the render scripts
        renderList.ForEach(scriptRenders =&gt; scriptRenders.ForEach(mesh =&gt; mesh?.Render()));

        // after render
        foreach (RenderScript script in renderScripts)
        {
            // advance the render scripts
            script.args = args;
            script.Camera = Camera;
            script.Timer = Timer;
            script.Scene = this;

            script.AfterRender();
        }
    }
}
<br>}]]></description><link>api\scene.html</link><guid isPermaLink="false">API/Scene.md</guid><pubDate>Mon, 26 May 2025 11:54:03 GMT</pubDate></item><item><title><![CDATA[Program]]></title><description><![CDATA[ 
 ]]></description><link>program.html</link><guid isPermaLink="false">Program.md</guid><pubDate>Mon, 26 May 2025 10:30:54 GMT</pubDate></item></channel></rss>